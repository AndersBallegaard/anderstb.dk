[{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool but inside VYOS. I have also decided to use DNS64 given that the majority of my devices doesn\u0026rsquo;t have a built in CLAT implementation.\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration\"\u003eVYOS NAT64 configuration\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways,\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing.\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. If you are trying to replicate this, and isn\u0026rsquo;t running BGP in your homelab, just create a static route pointing 64:ff9b::/96 towards the IPv6 address of your Jool machine.\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. If you are trying to replicate this, and isn\u0026rsquo;t running BGP in your homelab, just create a static route pointing 64:ff9b::/96 towards the IPv6 address of your Jool machine. I however am running BGP in my homelab, so I will be using BGP for this setup.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by installing FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow let\u0026rsquo;s enable  BGP and restart FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s setup a BGP session, modify this to fit your enviorment\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. If you are trying to replicate this, and isn\u0026rsquo;t running BGP in your homelab, just create a static route pointing 64:ff9b::/96 towards the IPv6 address of your Jool machine. I however am running BGP in my homelab, so I will be using BGP for this setup.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by installing FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow let\u0026rsquo;s enable  BGP and restart FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s setup a BGP session, modify this to fit your enviorment\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eOn Ubuntu installing Jool is very easy, it is included in the default APT repository, so all you need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. If you are trying to replicate this, and isn\u0026rsquo;t running BGP in your homelab, just create a static route pointing 64:ff9b::/96 towards the IPv6 address of your Jool machine. I however am running BGP in my homelab, so I will be using BGP for this setup.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by installing FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow let\u0026rsquo;s enable  BGP and restart FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s setup a BGP session, modify this to fit your enviorment\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eOn Ubuntu installing Jool is very easy, it is included in the default APT repository, so all you need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. If you are trying to replicate this, and isn\u0026rsquo;t running BGP in your homelab, just create a static route pointing 64:ff9b::/96 towards the IPv6 address of your Jool machine. I however am running BGP in my homelab, so I will be using BGP for this setup.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by installing FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow let\u0026rsquo;s enable  BGP and restart FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s setup a BGP session, modify this to fit your enviorment\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eOn Ubuntu installing Jool is very easy, it is included in the default APT repository, so all you need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Load module\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo modprobe jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Make the change persistant\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. If you are trying to replicate this, and isn\u0026rsquo;t running BGP in your homelab, just create a static route pointing 64:ff9b::/96 towards the IPv6 address of your Jool machine. I however am running BGP in my homelab, so I will be using BGP for this setup.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by installing FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow let\u0026rsquo;s enable  BGP and restart FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s setup a BGP session, modify this to fit your enviorment\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eOn Ubuntu installing Jool is very easy, it is included in the default APT repository, so all you need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. If you are trying to replicate this, and isn\u0026rsquo;t running BGP in your homelab, just create a static route pointing 64:ff9b::/96 towards the IPv6 address of your Jool machine. I however am running BGP in my homelab, so I will be using BGP for this setup.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by installing FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow let\u0026rsquo;s enable  BGP and restart FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s setup a BGP session, modify this to fit your enviorment\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eOn Ubuntu installing Jool is very easy, it is included in the default APT repository, so all you need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. If you are trying to replicate this, and isn\u0026rsquo;t running BGP in your homelab, just create a static route pointing 64:ff9b::/96 towards the IPv6 address of your Jool machine. I however am running BGP in my homelab, so I will be using BGP for this setup.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by installing FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow let\u0026rsquo;s enable  BGP and restart FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s setup a BGP session, modify this to fit your enviorment\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eOn Ubuntu installing Jool is very easy, it is included in the default APT repository, so all you need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. If you are trying to replicate this, and isn\u0026rsquo;t running BGP in your homelab, just create a static route pointing 64:ff9b::/96 towards the IPv6 address of your Jool machine. I however am running BGP in my homelab, so I will be using BGP for this setup.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by installing FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow let\u0026rsquo;s enable  BGP and restart FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s setup a BGP session, modify this to fit your enviorment\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eOn Ubuntu installing Jool is very easy, it is included in the default APT repository, so all you need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. If you are trying to replicate this, and isn\u0026rsquo;t running BGP in your homelab, just create a static route pointing 64:ff9b::/96 towards the IPv6 address of your Jool machine. I however am running BGP in my homelab, so I will be using BGP for this setup.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by installing FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow let\u0026rsquo;s enable  BGP and restart FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s setup a BGP session, modify this to fit your enviorment\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eOn Ubuntu installing Jool is very easy, it is included in the default APT repository, so all you need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. If you are trying to replicate this, and isn\u0026rsquo;t running BGP in your homelab, just create a static route pointing 64:ff9b::/96 towards the IPv6 address of your Jool machine. I however am running BGP in my homelab, so I will be using BGP for this setup.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by installing FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow let\u0026rsquo;s enable  BGP and restart FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s setup a BGP session, modify this to fit your enviorment\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eOn Ubuntu installing Jool is very easy, it is included in the default APT repository, so all you need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. If you are trying to replicate this, and isn\u0026rsquo;t running BGP in your homelab, just create a static route pointing 64:ff9b::/96 towards the IPv6 address of your Jool machine. I however am running BGP in my homelab, so I will be using BGP for this setup.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by installing FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow let\u0026rsquo;s enable  BGP and restart FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s setup a BGP session, modify this to fit your enviorment\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eOn Ubuntu installing Jool is very easy, it is included in the default APT repository, so all you need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. If you are trying to replicate this, and isn\u0026rsquo;t running BGP in your homelab, just create a static route pointing 64:ff9b::/96 towards the IPv6 address of your Jool machine. I however am running BGP in my homelab, so I will be using BGP for this setup.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by installing FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow let\u0026rsquo;s enable  BGP and restart FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s setup a BGP session, modify this to fit your enviorment\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eOn Ubuntu installing Jool is very easy, it is included in the default APT repository, so all you need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. If you are trying to replicate this, and isn\u0026rsquo;t running BGP in your homelab, just create a static route pointing 64:ff9b::/96 towards the IPv6 address of your Jool machine. I however am running BGP in my homelab, so I will be using BGP for this setup.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by installing FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow let\u0026rsquo;s enable  BGP and restart FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s setup a BGP session, modify this to fit your enviorment\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eOn Ubuntu installing Jool is very easy, it is included in the default APT repository, so all you need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. If you are trying to replicate this, and isn\u0026rsquo;t running BGP in your homelab, just create a static route pointing 64:ff9b::/96 towards the IPv6 address of your Jool machine. I however am running BGP in my homelab, so I will be using BGP for this setup.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by installing FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow let\u0026rsquo;s enable  BGP and restart FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s setup a BGP session, modify this to fit your enviorment\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eOn Ubuntu installing Jool is very easy, it is included in the default APT repository, so all you need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. If you are trying to replicate this, and isn\u0026rsquo;t running BGP in your homelab, just create a static route pointing 64:ff9b::/96 towards the IPv6 address of your Jool machine. I however am running BGP in my homelab, so I will be using BGP for this setup.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by installing FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow let\u0026rsquo;s enable  BGP and restart FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s setup a BGP session, modify this to fit your enviorment\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eOn Ubuntu installing Jool is very easy, it is included in the default APT repository, so all you need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. If you are trying to replicate this, and isn\u0026rsquo;t running BGP in your homelab, just create a static route pointing 64:ff9b::/96 towards the IPv6 address of your Jool machine. I however am running BGP in my homelab, so I will be using BGP for this setup.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by installing FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow let\u0026rsquo;s enable  BGP and restart FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s setup a BGP session, modify this to fit your enviorment\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eOn Ubuntu installing Jool is very easy, it is included in the default APT repository, so all you need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. If you are trying to replicate this, and isn\u0026rsquo;t running BGP in your homelab, just create a static route pointing 64:ff9b::/96 towards the IPv6 address of your Jool machine. I however am running BGP in my homelab, so I will be using BGP for this setup.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by installing FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow let\u0026rsquo;s enable  BGP and restart FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s setup a BGP session, modify this to fit your enviorment\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup.\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, I initially thought Jool would be the most interesting option, but I just could not get it to work on my Ubuntu 24.04 LTS system. I could see it did something, but it was not working properly.\u003c/p\u003e\n\u003ch2 id=\"my-setup-old\"\u003eMy setup \u0026ndash;old\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eOn Ubuntu installing Jool is very easy, it is included in the default APT repository, so all you need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. If you are trying to replicate this, and isn\u0026rsquo;t running BGP in your homelab, just create a static route pointing 64:ff9b::/96 towards the IPv6 address of your Jool machine. I however am running BGP in my homelab, so I will be using BGP for this setup.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by installing FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow let\u0026rsquo;s enable  BGP and restart FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s setup a BGP session, modify this to fit your enviorment\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup.\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, I initially thought Jool would be the most interesting option, but I just could not get it to work on my Ubuntu 24.04 LTS system. I could see it did something, but it was not working properly.\u003c/p\u003e\n\u003ch2 id=\"my-setup-1\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eOn Ubuntu installing Jool is very easy, it is included in the default APT repository, so all you need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. If you are trying to replicate this, and isn\u0026rsquo;t running BGP in your homelab, just create a static route pointing 64:ff9b::/96 towards the IPv6 address of your Jool machine. I however am running BGP in my homelab, so I will be using BGP for this setup.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by installing FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow let\u0026rsquo;s enable  BGP and restart FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s setup a BGP session, modify this to fit your enviorment\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eOn Ubuntu installing Jool is very easy, it is included in the default APT repository, so all you need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. If you are trying to replicate this, and isn\u0026rsquo;t running BGP in your homelab, just create a static route pointing 64:ff9b::/96 towards the IPv6 address of your Jool machine. I however am running BGP in my homelab, so I will be using BGP for this setup.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by installing FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow let\u0026rsquo;s enable  BGP and restart FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s setup a BGP session, modify this to fit your enviorment\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eIn theroy installing Jool on Ubuntu should be very easy, it is included in the default APT repository, so all you should need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI would recormend you try the above mentioned route, but as of writing, it doesn\u0026rsquo;t work. The version of Jool in the repo is too old, and does not support the current kernel version for Ubuntu 24.04 LTS. So here is the manuel way\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. If you are trying to replicate this, and isn\u0026rsquo;t running BGP in your homelab, just create a static route pointing 64:ff9b::/96 towards the IPv6 address of your Jool machine. I however am running BGP in my homelab, so I will be using BGP for this setup.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by installing FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow let\u0026rsquo;s enable  BGP and restart FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s setup a BGP session, modify this to fit your enviorment\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eIn theroy installing Jool on Ubuntu should be very easy, it is included in the default APT repository, so all you should need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI would recormend you try the above mentioned route, but as of writing, it doesn\u0026rsquo;t work. The version of Jool in the repo is too old, and does not support the current kernel version for Ubuntu 24.04 LTS. So here is the manuel way\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Find the newest versions here: \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e--2025-07-13 14:52:14--  https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. If you are trying to replicate this, and isn\u0026rsquo;t running BGP in your homelab, just create a static route pointing 64:ff9b::/96 towards the IPv6 address of your Jool machine. I however am running BGP in my homelab, so I will be using BGP for this setup.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by installing FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow let\u0026rsquo;s enable  BGP and restart FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s setup a BGP session, modify this to fit your enviorment\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eIn theroy installing Jool on Ubuntu should be very easy, it is included in the default APT repository, so all you should need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI would recormend you try the above mentioned route, but as of writing, it doesn\u0026rsquo;t work. The version of Jool in the repo is too old, and does not support the current kernel version for Ubuntu 24.04 LTS. So here is the manuel way\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Find the newest versions here: \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. If you are trying to replicate this, and isn\u0026rsquo;t running BGP in your homelab, just create a static route pointing 64:ff9b::/96 towards the IPv6 address of your Jool machine. I however am running BGP in my homelab, so I will be using BGP for this setup.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by installing FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow let\u0026rsquo;s enable  BGP and restart FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s setup a BGP session, modify this to fit your enviorment\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eIn theroy installing Jool on Ubuntu should be very easy, it is included in the default APT repository, so all you should need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI would recormend you try the above mentioned route, but as of writing, it doesn\u0026rsquo;t work. The version of Jool in the repo is too old, and does not support the current kernel version for Ubuntu 24.04 LTS. So here is the manuel way\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Find the newest versions here: https://github.com/NICMx/Jool/releases\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. If you are trying to replicate this, and isn\u0026rsquo;t running BGP in your homelab, just create a static route pointing 64:ff9b::/96 towards the IPv6 address of your Jool machine. I however am running BGP in my homelab, so I will be using BGP for this setup.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by installing FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow let\u0026rsquo;s enable  BGP and restart FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s setup a BGP session, modify this to fit your enviorment\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eIn theroy installing Jool on Ubuntu should be very easy, it is included in the default APT repository, so all you should need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI would recormend you try the above mentioned route, but as of writing, it doesn\u0026rsquo;t work. The version of Jool in the repo is too old, and does not support the current kernel version for Ubuntu 24.04 LTS. So here is the manuel way\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Find the newest versions here: https://github.com/NICMx/Jool/releases\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install kernel headers\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapt install linux-headers-\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003euname -r\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. If you are trying to replicate this, and isn\u0026rsquo;t running BGP in your homelab, just create a static route pointing 64:ff9b::/96 towards the IPv6 address of your Jool machine. I however am running BGP in my homelab, so I will be using BGP for this setup.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by installing FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow let\u0026rsquo;s enable  BGP and restart FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s setup a BGP session, modify this to fit your enviorment\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eIn theroy installing Jool on Ubuntu should be very easy, it is included in the default APT repository, so all you should need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI would recormend you try the above mentioned route, but as of writing, it doesn\u0026rsquo;t work. The version of Jool in the repo is too old, and does not support the current kernel version for Ubuntu 24.04 LTS. So here is the manuel way\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Find the newest versions here: https://github.com/NICMx/Jool/releases\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Download kernel module and tools\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install kernel headers\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapt install linux-headers-\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003euname -r\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install the packages\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo dpkg -i jool-*.deb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"setting-up-bgp\"\u003eSetting up BGP\u003c/h4\u003e\n\u003cp\u003eIn my case the NAT64 router is out of the normal path of traffic, this means we have to do some routing to make sure the NAT64 prefix is routed towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. If you are trying to replicate this, and isn\u0026rsquo;t running BGP in your homelab, just create a static route pointing 64:ff9b::/96 towards the IPv6 address of your Jool machine. I however am running BGP in my homelab, so I will be using BGP for this setup.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by installing FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eNow let\u0026rsquo;s enable  BGP and restart FRR\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s setup a BGP session, modify this to fit your enviorment\u003c/p\u003e\n\u003ch3 id=\"vyos-nat64-configuration--old-\"\u003eVYOS NAT64 configuration \u0026ndash; OLD \u0026mdash;\u003c/h3\u003e\n\u003cp\u003eEven though i have sevral diffrent VYOS routers in my network, i have decided to setup a new router for this purpose. I am mainly doing this for seperation of functions, and because any excuse to complicate my home networks routing is a good one.\u003c/p\u003e\n\u003cp\u003eTo start out with, i am only building one router, but i might add redundancy in the future\u003c/p\u003e\n\u003cp\u003eI will be using the following configuration:\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Set the IPv4 external address, in my case i just use DHCP\nset interfaces ethernet eth0 address dhcp\n\n# Setup a loopback IP for mgmt\nset interfaces loopback lo address 3fff::64:a/128\n\n# Set the IPv6 address\nset interfaces ethernet eth0 address 3fff:64:ff9b::b/64\n\n# Setup routing, in my case this router will be part of my ASN AS201911. Using a private ASN, or static routing is absolutly also an option.\nset policy prefix-list6 ANY6 rule 1 prefix ::/0\nset policy prefix-list6 ANY6 rule 1 ge 0\nset policy prefix-list6 ANY6 rule 1 action permit\n\nset policy prefix-list6 EXPORT rule 1 action permit\nset policy prefix-list6 EXPORT rule 1 prefix 3fff::64:a/128\nset policy prefix-list6 EXPORT rule 2 action permit\nset policy prefix-list6 EXPORT rule 2 prefix 64:ff9b::/96\n\nset protocols bgp system-as 201911\nset protocols bgp peer-group INTERNAL remote-as 201911\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list export EXPORT\nset protocols bgp peer-group INTERNAL address-family ipv6-unicast prefix-list import ANY6\nset protocols bgp address-family ipv6-unicast redistribute connected\nset protocols bgp address-family ipv6-unicast redistribute static\nset protocols bgp address-family ipv6-unicast network 64:ff9b::/96\n\nset protocols bgp neighbor 3fff:64:ff9b::a peer-group INTERNAL\n\n# Configure NAT64\nset nat64 source rule 100 source prefix \u0026#39;64:ff9b::/96\u0026#39;\nset nat64 source rule 100 translation pool 1 address 100.127.255.1\nset nat64 source rule 100 translation pool 1 port \u0026#39;2000-65000\u0026#39;\n\n# NAT64 really wants a static ip, but since i want to configure my interface as DHCP, i am creating an internal interface and NAT44\u0026#39;ing that interface.\nset interfaces dummy dum0 description VIRTUAL_NAT64_OUTSIDE\nset interfaces dummy dum0 address 100.127.255.1/24\n\nset nat source rule 100 outbound-interface name \u0026#39;eth0\u0026#39;\nset nat source rule 100 source address \u0026#39;100.127.255.0/24\u0026#39;\nset nat source rule 100 translation address \u0026#39;masquerade\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eIn theroy installing Jool on Ubuntu should be very easy, it is included in the default APT repository, so all you should need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI would recormend you try the above mentioned route, but as of writing, it doesn\u0026rsquo;t work. The version of Jool in the repo is too old, and does not support the current kernel version for Ubuntu 24.04 LTS. So here is the manuel way\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Find the newest versions here: https://github.com/NICMx/Jool/releases\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Download kernel module and tools\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install kernel headers\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapt install linux-headers-\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003euname -r\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install the packages\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo dpkg -i jool-*.deb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"routing\"\u003eRouting\u003c/h4\u003e\n\u003ch4 id=\"final-verification\"\u003eFinal verification\u003c/h4\u003e\n","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eIn theroy installing Jool on Ubuntu should be very easy, it is included in the default APT repository, so all you should need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI would recormend you try the above mentioned route, but as of writing, it doesn\u0026rsquo;t work. The version of Jool in the repo is too old, and does not support the current kernel version for Ubuntu 24.04 LTS. So here is the manuel way\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Find the newest versions here: https://github.com/NICMx/Jool/releases\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Download kernel module and tools\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install kernel headers\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapt install linux-headers-\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003euname -r\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install the packages\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo dpkg -i jool-*.deb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"routing\"\u003eRouting\u003c/h4\u003e\n\u003cp\u003eGiven this guide assumes the NAT64 router is outside the normal path of traffic, we need to route the NAT64 prefix towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. For simplicity I have decided to use Static routing.\u003c/p\u003e\n\u003cp\u003eI unfortunly can\u0026rsquo;t tell you exactly how to configure this routing, due to it being slightly diffrent on each router OS. But here is an example from Vyos:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"final-verification\"\u003eFinal verification\u003c/h4\u003e\n","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eIn theroy installing Jool on Ubuntu should be very easy, it is included in the default APT repository, so all you should need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI would recormend you try the above mentioned route, but as of writing, it doesn\u0026rsquo;t work. The version of Jool in the repo is too old, and does not support the current kernel version for Ubuntu 24.04 LTS. So here is the manuel way\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Find the newest versions here: https://github.com/NICMx/Jool/releases\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Download kernel module and tools\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install kernel headers\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapt install linux-headers-\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003euname -r\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install the packages\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo dpkg -i jool-*.deb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"routing\"\u003eRouting\u003c/h4\u003e\n\u003cp\u003eGiven this guide assumes the NAT64 router is outside the normal path of traffic, we need to route the NAT64 prefix towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. For simplicity I have decided to use Static routing.\u003c/p\u003e\n\u003cp\u003eI unfortunly can\u0026rsquo;t tell you exactly how to configure this routing, due to it being slightly diffrent on each router OS. But here is an example from Vyos:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset protocols static route6 64:ff9b::/96 next-hop \u0026lt;Your machines IP\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"final-verification\"\u003eFinal verification\u003c/h4\u003e\n","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eIn theroy installing Jool on Ubuntu should be very easy, it is included in the default APT repository, so all you should need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI would recormend you try the above mentioned route, but as of writing, it doesn\u0026rsquo;t work. The version of Jool in the repo is too old, and does not support the current kernel version for Ubuntu 24.04 LTS. So here is the manuel way\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Find the newest versions here: https://github.com/NICMx/Jool/releases\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Download kernel module and tools\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install kernel headers\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapt install linux-headers-\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003euname -r\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install the packages\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo dpkg -i jool-*.deb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"routing\"\u003eRouting\u003c/h4\u003e\n\u003cp\u003eGiven this guide assumes the NAT64 router is outside the normal path of traffic, we need to route the NAT64 prefix towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. For simplicity I have decided to use Static routing.\u003c/p\u003e\n\u003cp\u003eI unfortunly can\u0026rsquo;t tell you exactly how to configure this routing, due to it being slightly diffrent on each router OS. But here is an example from Vyos:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset protocols static route6 64:ff9b::/96 next-hop \u0026lt;Your machines IP\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"final-verification-of-jool\"\u003eFinal verification of Jool\u003c/h4\u003e\n\u003cp\u003eLet\u0026rsquo;s try running some traffic through the NAT64 router and see if it works. To start out with, let\u0026rsquo;s use ping to test this.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# From a host on the Lan side NOT THE NAT64 ROUTER ITSELF, ping google though the nat64 prefix.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eIn theroy installing Jool on Ubuntu should be very easy, it is included in the default APT repository, so all you should need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI would recormend you try the above mentioned route, but as of writing, it doesn\u0026rsquo;t work. The version of Jool in the repo is too old, and does not support the current kernel version for Ubuntu 24.04 LTS. So here is the manuel way\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Find the newest versions here: https://github.com/NICMx/Jool/releases\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Download kernel module and tools\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install kernel headers\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapt install linux-headers-\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003euname -r\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install the packages\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo dpkg -i jool-*.deb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"routing\"\u003eRouting\u003c/h4\u003e\n\u003cp\u003eGiven this guide assumes the NAT64 router is outside the normal path of traffic, we need to route the NAT64 prefix towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. For simplicity I have decided to use Static routing.\u003c/p\u003e\n\u003cp\u003eI unfortunly can\u0026rsquo;t tell you exactly how to configure this routing, due to it being slightly diffrent on each router OS. But here is an example from Vyos:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset protocols static route6 64:ff9b::/96 next-hop \u0026lt;Your machines IP\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"final-verification-of-jool\"\u003eFinal verification of Jool\u003c/h4\u003e\n\u003cp\u003eLet\u0026rsquo;s try running some traffic through the NAT64 router and see if it works. To start out with, let\u0026rsquo;s use ping to test this.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# From a host on the Lan side NOT THE NAT64 ROUTER ITSELF, ping 1.1.1.1 though the nat64 prefix.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e➜  ~ ping 64:ff9b::1.1.1.1 -c \u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePING 64:ff9b::1.1.1.1\u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003e64:ff9b::101:101\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e56\u003c/span\u003e data bytes\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e5.67 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e6.71 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e7.13 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e8.18 ms\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eIn theroy installing Jool on Ubuntu should be very easy, it is included in the default APT repository, so all you should need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI would recormend you try the above mentioned route, but as of writing, it doesn\u0026rsquo;t work. The version of Jool in the repo is too old, and does not support the current kernel version for Ubuntu 24.04 LTS. So here is the manuel way\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Find the newest versions here: https://github.com/NICMx/Jool/releases\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Download kernel module and tools\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install kernel headers\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapt install linux-headers-\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003euname -r\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install the packages\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo dpkg -i jool-*.deb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"routing\"\u003eRouting\u003c/h4\u003e\n\u003cp\u003eGiven this guide assumes the NAT64 router is outside the normal path of traffic, we need to route the NAT64 prefix towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. For simplicity I have decided to use Static routing.\u003c/p\u003e\n\u003cp\u003eI unfortunly can\u0026rsquo;t tell you exactly how to configure this routing, due to it being slightly diffrent on each router OS. But here is an example from Vyos:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset protocols static route6 64:ff9b::/96 next-hop \u0026lt;Your machines IP\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"final-verification-of-jool\"\u003eFinal verification of Jool\u003c/h4\u003e\n\u003cp\u003eLet\u0026rsquo;s try running some traffic through the NAT64 router and see if it works. To start out with, let\u0026rsquo;s use ping to test this.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# From a host on the Lan side NOT THE NAT64 ROUTER ITSELF, ping 1.1.1.1 though the nat64 prefix.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e➜  ~ ping 64:ff9b::1.1.1.1 \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePING 64:ff9b::1.1.1.1\u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003e64:ff9b::101:101\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e56\u003c/span\u003e data bytes\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e5.67 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e6.71 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e7.13 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e8.18 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# While that is running let\u0026#39;s look on the Jool machine itself. We should be able to see the sessions\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eIn theroy installing Jool on Ubuntu should be very easy, it is included in the default APT repository, so all you should need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI would recormend you try the above mentioned route, but as of writing, it doesn\u0026rsquo;t work. The version of Jool in the repo is too old, and does not support the current kernel version for Ubuntu 24.04 LTS. So here is the manuel way\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Find the newest versions here: https://github.com/NICMx/Jool/releases\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Download kernel module and tools\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install kernel headers\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapt install linux-headers-\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003euname -r\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install the packages\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo dpkg -i jool-*.deb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"routing\"\u003eRouting\u003c/h4\u003e\n\u003cp\u003eGiven this guide assumes the NAT64 router is outside the normal path of traffic, we need to route the NAT64 prefix towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. For simplicity I have decided to use Static routing.\u003c/p\u003e\n\u003cp\u003eI unfortunly can\u0026rsquo;t tell you exactly how to configure this routing, due to it being slightly diffrent on each router OS. But here is an example from Vyos:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset protocols static route6 64:ff9b::/96 next-hop \u0026lt;Your machines IP\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"final-verification-of-jool\"\u003eFinal verification of Jool\u003c/h4\u003e\n\u003cp\u003eLet\u0026rsquo;s try running some traffic through the NAT64 router and see if it works. To start out with, let\u0026rsquo;s use ping to test this.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# From a host on the Lan side NOT THE NAT64 ROUTER ITSELF, ping 1.1.1.1 though the nat64 prefix.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e➜  ~ ping 64:ff9b::1.1.1.1 \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePING 64:ff9b::1.1.1.1\u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003e64:ff9b::101:101\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e56\u003c/span\u003e data bytes\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e5.67 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e6.71 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e7.13 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e8.18 ms\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"adding-dns64\"\u003eAdding DNS64\u003c/h3\u003e\n\u003cp\u003eWhile some hosts\u003c/p\u003e\n","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eIn theroy installing Jool on Ubuntu should be very easy, it is included in the default APT repository, so all you should need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI would recormend you try the above mentioned route, but as of writing, it doesn\u0026rsquo;t work. The version of Jool in the repo is too old, and does not support the current kernel version for Ubuntu 24.04 LTS. So here is the manuel way\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Find the newest versions here: https://github.com/NICMx/Jool/releases\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Download kernel module and tools\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install kernel headers\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapt install linux-headers-\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003euname -r\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install the packages\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo dpkg -i jool-*.deb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"routing\"\u003eRouting\u003c/h4\u003e\n\u003cp\u003eGiven this guide assumes the NAT64 router is outside the normal path of traffic, we need to route the NAT64 prefix towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. For simplicity I have decided to use Static routing.\u003c/p\u003e\n\u003cp\u003eI unfortunly can\u0026rsquo;t tell you exactly how to configure this routing, due to it being slightly diffrent on each router OS. But here is an example from Vyos:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset protocols static route6 64:ff9b::/96 next-hop \u0026lt;Your machines IP\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"final-verification-of-jool\"\u003eFinal verification of Jool\u003c/h4\u003e\n\u003cp\u003eLet\u0026rsquo;s try running some traffic through the NAT64 router and see if it works. To start out with, let\u0026rsquo;s use ping to test this.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# From a host on the Lan side NOT THE NAT64 ROUTER ITSELF, ping 1.1.1.1 though the nat64 prefix.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e➜  ~ ping 64:ff9b::1.1.1.1 \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePING 64:ff9b::1.1.1.1\u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003e64:ff9b::101:101\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e56\u003c/span\u003e data bytes\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e5.67 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e6.71 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e7.13 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e8.18 ms\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"adding-dns64\"\u003eAdding DNS64\u003c/h3\u003e\n\u003cp\u003eWhile some hosts might\u003c/p\u003e\n","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eIn theroy installing Jool on Ubuntu should be very easy, it is included in the default APT repository, so all you should need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI would recormend you try the above mentioned route, but as of writing, it doesn\u0026rsquo;t work. The version of Jool in the repo is too old, and does not support the current kernel version for Ubuntu 24.04 LTS. So here is the manuel way\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Find the newest versions here: https://github.com/NICMx/Jool/releases\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Download kernel module and tools\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install kernel headers\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapt install linux-headers-\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003euname -r\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install the packages\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo dpkg -i jool-*.deb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"routing\"\u003eRouting\u003c/h4\u003e\n\u003cp\u003eGiven this guide assumes the NAT64 router is outside the normal path of traffic, we need to route the NAT64 prefix towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. For simplicity I have decided to use Static routing.\u003c/p\u003e\n\u003cp\u003eI unfortunly can\u0026rsquo;t tell you exactly how to configure this routing, due to it being slightly diffrent on each router OS. But here is an example from Vyos:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset protocols static route6 64:ff9b::/96 next-hop \u0026lt;Your machines IP\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"final-verification-of-jool\"\u003eFinal verification of Jool\u003c/h4\u003e\n\u003cp\u003eLet\u0026rsquo;s try running some traffic through the NAT64 router and see if it works. To start out with, let\u0026rsquo;s use ping to test this.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# From a host on the Lan side NOT THE NAT64 ROUTER ITSELF, ping 1.1.1.1 though the nat64 prefix.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e➜  ~ ping 64:ff9b::1.1.1.1 \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePING 64:ff9b::1.1.1.1\u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003e64:ff9b::101:101\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e56\u003c/span\u003e data bytes\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e5.67 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e6.71 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e7.13 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e8.18 ms\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"adding-dns64\"\u003eAdding DNS64\u003c/h3\u003e\n\u003cp\u003eWhile some hosts might automaticly discover the NAT64 router, it is unlikely. Therefore we need a DNS64 server.\nThis might be something i built in the future, but for now i will just use a publicly avalible one. These servers assume you use 64:ff9b::/96 as your NAT64 prefix, so this is not an option if you are using a different prefix.\u003c/p\u003e\n\u003cp\u003eHere is a list of public DNS64 servers:\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eName\u003c/th\u003e\n          \u003cth\u003eAddress\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eIn theroy installing Jool on Ubuntu should be very easy, it is included in the default APT repository, so all you should need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI would recormend you try the above mentioned route, but as of writing, it doesn\u0026rsquo;t work. The version of Jool in the repo is too old, and does not support the current kernel version for Ubuntu 24.04 LTS. So here is the manuel way\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Find the newest versions here: https://github.com/NICMx/Jool/releases\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Download kernel module and tools\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install kernel headers\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapt install linux-headers-\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003euname -r\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install the packages\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo dpkg -i jool-*.deb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"routing\"\u003eRouting\u003c/h4\u003e\n\u003cp\u003eGiven this guide assumes the NAT64 router is outside the normal path of traffic, we need to route the NAT64 prefix towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. For simplicity I have decided to use Static routing.\u003c/p\u003e\n\u003cp\u003eI unfortunly can\u0026rsquo;t tell you exactly how to configure this routing, due to it being slightly diffrent on each router OS. But here is an example from Vyos:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset protocols static route6 64:ff9b::/96 next-hop \u0026lt;Your machines IP\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"final-verification-of-jool\"\u003eFinal verification of Jool\u003c/h4\u003e\n\u003cp\u003eLet\u0026rsquo;s try running some traffic through the NAT64 router and see if it works. To start out with, let\u0026rsquo;s use ping to test this.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# From a host on the Lan side NOT THE NAT64 ROUTER ITSELF, ping 1.1.1.1 though the nat64 prefix.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e➜  ~ ping 64:ff9b::1.1.1.1 \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePING 64:ff9b::1.1.1.1\u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003e64:ff9b::101:101\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e56\u003c/span\u003e data bytes\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e5.67 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e6.71 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e7.13 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e8.18 ms\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"adding-dns64\"\u003eAdding DNS64\u003c/h3\u003e\n\u003cp\u003eWhile some hosts might automaticly discover the NAT64 router, it is unlikely. Therefore we need a DNS64 server.\nThis might be something i built in the future, but for now i will just use a publicly avalible one. These servers assume you use 64:ff9b::/96 as your NAT64 prefix, so this is not an option if you are using a different prefix.\u003c/p\u003e\n\u003cp\u003eHere is a list of public DNS64 servers:\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eName\u003c/th\u003e\n          \u003cth\u003eAddress\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eGoogle - Primary\u003c/td\u003e\n          \u003ctd\u003e2001:4860:4860::6464\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eGoogle - Secondary\u003c/td\u003e\n          \u003ctd\u003e2001:4860:4860::6470\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eIn theroy installing Jool on Ubuntu should be very easy, it is included in the default APT repository, so all you should need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI would recormend you try the above mentioned route, but as of writing, it doesn\u0026rsquo;t work. The version of Jool in the repo is too old, and does not support the current kernel version for Ubuntu 24.04 LTS. So here is the manuel way\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Find the newest versions here: https://github.com/NICMx/Jool/releases\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Download kernel module and tools\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install kernel headers\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapt install linux-headers-\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003euname -r\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install the packages\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo dpkg -i jool-*.deb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"routing\"\u003eRouting\u003c/h4\u003e\n\u003cp\u003eGiven this guide assumes the NAT64 router is outside the normal path of traffic, we need to route the NAT64 prefix towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. For simplicity I have decided to use Static routing.\u003c/p\u003e\n\u003cp\u003eI unfortunly can\u0026rsquo;t tell you exactly how to configure this routing, due to it being slightly diffrent on each router OS. But here is an example from Vyos:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset protocols static route6 64:ff9b::/96 next-hop \u0026lt;Your machines IP\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"final-verification-of-jool\"\u003eFinal verification of Jool\u003c/h4\u003e\n\u003cp\u003eLet\u0026rsquo;s try running some traffic through the NAT64 router and see if it works. To start out with, let\u0026rsquo;s use ping to test this.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# From a host on the Lan side NOT THE NAT64 ROUTER ITSELF, ping 1.1.1.1 though the nat64 prefix.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e➜  ~ ping 64:ff9b::1.1.1.1 \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePING 64:ff9b::1.1.1.1\u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003e64:ff9b::101:101\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e56\u003c/span\u003e data bytes\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e5.67 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e6.71 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e7.13 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e8.18 ms\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"adding-dns64\"\u003eAdding DNS64\u003c/h3\u003e\n\u003cp\u003eWhile some hosts might automaticly discover the NAT64 router, it is unlikely. Therefore we need a DNS64 server.\nThis might be something i built in the future, but for now i will just use a publicly avalible one. These servers assume you use 64:ff9b::/96 as your NAT64 prefix, so this is not an option if you are using a different prefix.\u003c/p\u003e\n\u003cp\u003eHere is a list of public DNS64 servers:\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eName\u003c/th\u003e\n          \u003cth\u003eAddress\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eGoogle - Primary\u003c/td\u003e\n          \u003ctd\u003e2001:4860:4860::6464\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eGoogle - Secondary\u003c/td\u003e\n          \u003ctd\u003e2001:4860:4860::64\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eIn theroy installing Jool on Ubuntu should be very easy, it is included in the default APT repository, so all you should need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI would recormend you try the above mentioned route, but as of writing, it doesn\u0026rsquo;t work. The version of Jool in the repo is too old, and does not support the current kernel version for Ubuntu 24.04 LTS. So here is the manuel way\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Find the newest versions here: https://github.com/NICMx/Jool/releases\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Download kernel module and tools\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install kernel headers\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapt install linux-headers-\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003euname -r\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install the packages\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo dpkg -i jool-*.deb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"routing\"\u003eRouting\u003c/h4\u003e\n\u003cp\u003eGiven this guide assumes the NAT64 router is outside the normal path of traffic, we need to route the NAT64 prefix towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. For simplicity I have decided to use Static routing.\u003c/p\u003e\n\u003cp\u003eI unfortunly can\u0026rsquo;t tell you exactly how to configure this routing, due to it being slightly diffrent on each router OS. But here is an example from Vyos:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset protocols static route6 64:ff9b::/96 next-hop \u0026lt;Your machines IP\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"final-verification-of-jool\"\u003eFinal verification of Jool\u003c/h4\u003e\n\u003cp\u003eLet\u0026rsquo;s try running some traffic through the NAT64 router and see if it works. To start out with, let\u0026rsquo;s use ping to test this.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# From a host on the Lan side NOT THE NAT64 ROUTER ITSELF, ping 1.1.1.1 though the nat64 prefix.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e➜  ~ ping 64:ff9b::1.1.1.1 \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePING 64:ff9b::1.1.1.1\u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003e64:ff9b::101:101\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e56\u003c/span\u003e data bytes\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e5.67 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e6.71 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e7.13 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e8.18 ms\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"adding-dns64\"\u003eAdding DNS64\u003c/h3\u003e\n\u003cp\u003eWhile some hosts might automaticly discover the NAT64 router, it is unlikely. Therefore we need a DNS64 server.\nThis might be something i built in the future, but for now i will just use a publicly avalible one. These servers assume you use 64:ff9b::/96 as your NAT64 prefix, so this is not an option if you are using a different prefix.\u003c/p\u003e\n\u003cp\u003eHere is a list of public DNS64 servers:\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eName\u003c/th\u003e\n          \u003cth\u003eAddress\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eGoogle - Primary\u003c/td\u003e\n          \u003ctd\u003e2001:4860:4860::6464\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eGoogle - Secondary\u003c/td\u003e\n          \u003ctd\u003e2001:4860:4860::64\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCloudflare - Primary\u003c/td\u003e\n          \u003ctd\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eIn theroy installing Jool on Ubuntu should be very easy, it is included in the default APT repository, so all you should need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI would recormend you try the above mentioned route, but as of writing, it doesn\u0026rsquo;t work. The version of Jool in the repo is too old, and does not support the current kernel version for Ubuntu 24.04 LTS. So here is the manuel way\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Find the newest versions here: https://github.com/NICMx/Jool/releases\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Download kernel module and tools\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install kernel headers\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapt install linux-headers-\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003euname -r\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install the packages\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo dpkg -i jool-*.deb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"routing\"\u003eRouting\u003c/h4\u003e\n\u003cp\u003eGiven this guide assumes the NAT64 router is outside the normal path of traffic, we need to route the NAT64 prefix towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. For simplicity I have decided to use Static routing.\u003c/p\u003e\n\u003cp\u003eI unfortunly can\u0026rsquo;t tell you exactly how to configure this routing, due to it being slightly diffrent on each router OS. But here is an example from Vyos:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset protocols static route6 64:ff9b::/96 next-hop \u0026lt;Your machines IP\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"final-verification-of-jool\"\u003eFinal verification of Jool\u003c/h4\u003e\n\u003cp\u003eLet\u0026rsquo;s try running some traffic through the NAT64 router and see if it works. To start out with, let\u0026rsquo;s use ping to test this.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# From a host on the Lan side NOT THE NAT64 ROUTER ITSELF, ping 1.1.1.1 though the nat64 prefix.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e➜  ~ ping 64:ff9b::1.1.1.1 \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePING 64:ff9b::1.1.1.1\u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003e64:ff9b::101:101\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e56\u003c/span\u003e data bytes\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e5.67 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e6.71 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e7.13 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e8.18 ms\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"adding-dns64\"\u003eAdding DNS64\u003c/h3\u003e\n\u003cp\u003eWhile some hosts might automaticly discover the NAT64 router, it is unlikely. Therefore we need a DNS64 server.\nThis might be something i built in the future, but for now i will just use a publicly avalible one. These servers assume you use 64:ff9b::/96 as your NAT64 prefix, so this is not an option if you are using a different prefix.\u003c/p\u003e\n\u003cp\u003eHere is a list of public DNS64 servers:\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eName\u003c/th\u003e\n          \u003cth\u003eAddress\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eGoogle - Primary\u003c/td\u003e\n          \u003ctd\u003e2001:4860:4860::6464\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eGoogle - Secondary\u003c/td\u003e\n          \u003ctd\u003e2001:4860:4860::64\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCloudflare - Primary\u003c/td\u003e\n          \u003ctd\u003e2606:4700:4700::64\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCloudflare - Secondary\u003c/td\u003e\n          \u003ctd\u003e2606:4700:4700::11\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eIn theroy installing Jool on Ubuntu should be very easy, it is included in the default APT repository, so all you should need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI would recormend you try the above mentioned route, but as of writing, it doesn\u0026rsquo;t work. The version of Jool in the repo is too old, and does not support the current kernel version for Ubuntu 24.04 LTS. So here is the manuel way\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Find the newest versions here: https://github.com/NICMx/Jool/releases\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Download kernel module and tools\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install kernel headers\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapt install linux-headers-\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003euname -r\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install the packages\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo dpkg -i jool-*.deb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"routing\"\u003eRouting\u003c/h4\u003e\n\u003cp\u003eGiven this guide assumes the NAT64 router is outside the normal path of traffic, we need to route the NAT64 prefix towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. For simplicity I have decided to use Static routing.\u003c/p\u003e\n\u003cp\u003eI unfortunly can\u0026rsquo;t tell you exactly how to configure this routing, due to it being slightly diffrent on each router OS. But here is an example from Vyos:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset protocols static route6 64:ff9b::/96 next-hop \u0026lt;Your machines IP\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"final-verification-of-jool\"\u003eFinal verification of Jool\u003c/h4\u003e\n\u003cp\u003eLet\u0026rsquo;s try running some traffic through the NAT64 router and see if it works. To start out with, let\u0026rsquo;s use ping to test this.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# From a host on the Lan side NOT THE NAT64 ROUTER ITSELF, ping 1.1.1.1 though the nat64 prefix.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e➜  ~ ping 64:ff9b::1.1.1.1 \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePING 64:ff9b::1.1.1.1\u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003e64:ff9b::101:101\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e56\u003c/span\u003e data bytes\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e5.67 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e6.71 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e7.13 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e8.18 ms\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"adding-dns64\"\u003eAdding DNS64\u003c/h3\u003e\n\u003cp\u003eWhile some hosts might automaticly discover the NAT64 router, it is unlikely. Therefore we need a DNS64 server.\nThis might be something i built in the future, but for now i will just use a publicly avalible one. These servers assume you use 64:ff9b::/96 as your NAT64 prefix, so this is not an option if you are using a different prefix.\u003c/p\u003e\n\u003cp\u003eHere is a list of public DNS64 servers:\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eName\u003c/th\u003e\n          \u003cth\u003eAddress\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eGoogle - Primary\u003c/td\u003e\n          \u003ctd\u003e2001:4860:4860::6464\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eGoogle - Secondary\u003c/td\u003e\n          \u003ctd\u003e2001:4860:4860::64\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCloudflare - Primary\u003c/td\u003e\n          \u003ctd\u003e2606:4700:4700::64\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCloudflare - Secondary\u003c/td\u003e\n          \u003ctd\u003e2606:4700:4700::6400\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eIn theroy installing Jool on Ubuntu should be very easy, it is included in the default APT repository, so all you should need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI would recormend you try the above mentioned route, but as of writing, it doesn\u0026rsquo;t work. The version of Jool in the repo is too old, and does not support the current kernel version for Ubuntu 24.04 LTS. So here is the manuel way\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Find the newest versions here: https://github.com/NICMx/Jool/releases\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Download kernel module and tools\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install kernel headers\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapt install linux-headers-\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003euname -r\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install the packages\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo dpkg -i jool-*.deb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"routing\"\u003eRouting\u003c/h4\u003e\n\u003cp\u003eGiven this guide assumes the NAT64 router is outside the normal path of traffic, we need to route the NAT64 prefix towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. For simplicity I have decided to use Static routing.\u003c/p\u003e\n\u003cp\u003eI unfortunly can\u0026rsquo;t tell you exactly how to configure this routing, due to it being slightly diffrent on each router OS. But here is an example from Vyos:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset protocols static route6 64:ff9b::/96 next-hop \u0026lt;Your machines IP\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"final-verification-of-jool\"\u003eFinal verification of Jool\u003c/h4\u003e\n\u003cp\u003eLet\u0026rsquo;s try running some traffic through the NAT64 router and see if it works. To start out with, let\u0026rsquo;s use ping to test this.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# From a host on the Lan side NOT THE NAT64 ROUTER ITSELF, ping 1.1.1.1 though the nat64 prefix.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e➜  ~ ping 64:ff9b::1.1.1.1 \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePING 64:ff9b::1.1.1.1\u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003e64:ff9b::101:101\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e56\u003c/span\u003e data bytes\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e5.67 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e6.71 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e7.13 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e8.18 ms\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"adding-dns64\"\u003eAdding DNS64\u003c/h3\u003e\n\u003cp\u003eWhile some hosts might automaticly discover the NAT64 router, it is unlikely. Therefore we need a DNS64 server.\nThis might be something i built in the future, but for now i will just use a publicly avalible one. These servers assume you use 64:ff9b::/96 as your NAT64 prefix, so this is not an option if you are using a different prefix.\u003c/p\u003e\n\u003cp\u003eHere is a list of some public DNS64 servers:\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eName\u003c/th\u003e\n          \u003cth\u003eAddress\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eGoogle - Primary\u003c/td\u003e\n          \u003ctd\u003e2001:4860:4860::6464\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eGoogle - Secondary\u003c/td\u003e\n          \u003ctd\u003e2001:4860:4860::64\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCloudflare - Primary\u003c/td\u003e\n          \u003ctd\u003e2606:4700:4700::64\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCloudflare - Secondary\u003c/td\u003e\n          \u003ctd\u003e2606:4700:4700::6400\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eI will be using Cloudflares in my network.\u003c/p\u003e\n\u003cp\u003eAgain, this step depends on what router you are using (and your address alocation techniques).\u003c/p\u003e\n","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eIn theroy installing Jool on Ubuntu should be very easy, it is included in the default APT repository, so all you should need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI would recormend you try the above mentioned route, but as of writing, it doesn\u0026rsquo;t work. The version of Jool in the repo is too old, and does not support the current kernel version for Ubuntu 24.04 LTS. So here is the manuel way\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Find the newest versions here: https://github.com/NICMx/Jool/releases\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Download kernel module and tools\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install kernel headers\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapt install linux-headers-\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003euname -r\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install the packages\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo dpkg -i jool-*.deb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"routing\"\u003eRouting\u003c/h4\u003e\n\u003cp\u003eGiven this guide assumes the NAT64 router is outside the normal path of traffic, we need to route the NAT64 prefix towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. For simplicity I have decided to use Static routing.\u003c/p\u003e\n\u003cp\u003eI unfortunly can\u0026rsquo;t tell you exactly how to configure this routing, due to it being slightly diffrent on each router OS. But here is an example from Vyos:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset protocols static route6 64:ff9b::/96 next-hop \u0026lt;Your machines IP\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"final-verification-of-jool\"\u003eFinal verification of Jool\u003c/h4\u003e\n\u003cp\u003eLet\u0026rsquo;s try running some traffic through the NAT64 router and see if it works. To start out with, let\u0026rsquo;s use ping to test this.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# From a host on the Lan side NOT THE NAT64 ROUTER ITSELF, ping 1.1.1.1 though the nat64 prefix.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e➜  ~ ping 64:ff9b::1.1.1.1 \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePING 64:ff9b::1.1.1.1\u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003e64:ff9b::101:101\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e56\u003c/span\u003e data bytes\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e5.67 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e6.71 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e7.13 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e8.18 ms\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"adding-dns64\"\u003eAdding DNS64\u003c/h3\u003e\n\u003cp\u003eWhile some hosts might automaticly discover the NAT64 router, it is unlikely. Therefore we need a DNS64 server.\nThis might be something i built in the future, but for now i will just use a publicly avalible one. These servers assume you use 64:ff9b::/96 as your NAT64 prefix, so this is not an option if you are using a different prefix.\u003c/p\u003e\n\u003cp\u003eHere is a list of some public DNS64 servers:\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eName\u003c/th\u003e\n          \u003cth\u003eAddress\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eGoogle - Primary\u003c/td\u003e\n          \u003ctd\u003e2001:4860:4860::6464\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eGoogle - Secondary\u003c/td\u003e\n          \u003ctd\u003e2001:4860:4860::64\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCloudflare - Primary\u003c/td\u003e\n          \u003ctd\u003e2606:4700:4700::64\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCloudflare - Secondary\u003c/td\u003e\n          \u003ctd\u003e2606:4700:4700::6400\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eI will be using Cloudflares in my network.\u003c/p\u003e\n\u003cp\u003eAgain, this step depends on what router you are using (and your address alocation techniques). But you want to either update your router advertisements, or DHCPv6 to announce two DNS64 servers.\u003c/p\u003e\n","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eIn theroy installing Jool on Ubuntu should be very easy, it is included in the default APT repository, so all you should need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI would recormend you try the above mentioned route, but as of writing, it doesn\u0026rsquo;t work. The version of Jool in the repo is too old, and does not support the current kernel version for Ubuntu 24.04 LTS. So here is the manuel way\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Find the newest versions here: https://github.com/NICMx/Jool/releases\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Download kernel module and tools\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install kernel headers\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapt install linux-headers-\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003euname -r\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install the packages\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo dpkg -i jool-*.deb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"routing\"\u003eRouting\u003c/h4\u003e\n\u003cp\u003eGiven this guide assumes the NAT64 router is outside the normal path of traffic, we need to route the NAT64 prefix towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. For simplicity I have decided to use Static routing.\u003c/p\u003e\n\u003cp\u003eI unfortunly can\u0026rsquo;t tell you exactly how to configure this routing, due to it being slightly diffrent on each router OS. But here is an example from Vyos:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset protocols static route6 64:ff9b::/96 next-hop \u0026lt;Your machines IP\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"final-verification-of-jool\"\u003eFinal verification of Jool\u003c/h4\u003e\n\u003cp\u003eLet\u0026rsquo;s try running some traffic through the NAT64 router and see if it works. To start out with, let\u0026rsquo;s use ping to test this.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# From a host on the Lan side NOT THE NAT64 ROUTER ITSELF, ping 1.1.1.1 though the nat64 prefix.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e➜  ~ ping 64:ff9b::1.1.1.1 \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePING 64:ff9b::1.1.1.1\u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003e64:ff9b::101:101\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e56\u003c/span\u003e data bytes\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e5.67 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e6.71 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e7.13 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e8.18 ms\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"adding-dns64\"\u003eAdding DNS64\u003c/h3\u003e\n\u003cp\u003eWhile some hosts might automaticly discover the NAT64 router, it is unlikely. Therefore we need a DNS64 server.\nThis might be something i built in the future, but for now i will just use a publicly avalible one. These servers assume you use 64:ff9b::/96 as your NAT64 prefix, so this is not an option if you are using a different prefix.\u003c/p\u003e\n\u003cp\u003eHere is a list of some public DNS64 servers:\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eName\u003c/th\u003e\n          \u003cth\u003eAddress\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eGoogle - Primary\u003c/td\u003e\n          \u003ctd\u003e2001:4860:4860::6464\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eGoogle - Secondary\u003c/td\u003e\n          \u003ctd\u003e2001:4860:4860::64\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCloudflare - Primary\u003c/td\u003e\n          \u003ctd\u003e2606:4700:4700::64\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCloudflare - Secondary\u003c/td\u003e\n          \u003ctd\u003e2606:4700:4700::6400\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eI will be using Cloudflares in my network.\u003c/p\u003e\n\u003cp\u003eAgain, this step depends on what router you are using (and your address alocation techniques). But you want to either update your router advertisements, or DHCPv6 to announce two DNS64 servers.\u003c/p\u003e\n\u003cp\u003eOnce you have done that, you can use curl to test that it works\u003c/p\u003e\n","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eIn theroy installing Jool on Ubuntu should be very easy, it is included in the default APT repository, so all you should need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI would recormend you try the above mentioned route, but as of writing, it doesn\u0026rsquo;t work. The version of Jool in the repo is too old, and does not support the current kernel version for Ubuntu 24.04 LTS. So here is the manuel way\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Find the newest versions here: https://github.com/NICMx/Jool/releases\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Download kernel module and tools\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install kernel headers\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapt install linux-headers-\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003euname -r\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install the packages\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo dpkg -i jool-*.deb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"routing\"\u003eRouting\u003c/h4\u003e\n\u003cp\u003eGiven this guide assumes the NAT64 router is outside the normal path of traffic, we need to route the NAT64 prefix towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. For simplicity I have decided to use Static routing.\u003c/p\u003e\n\u003cp\u003eI unfortunly can\u0026rsquo;t tell you exactly how to configure this routing, due to it being slightly diffrent on each router OS. But here is an example from Vyos:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset protocols static route6 64:ff9b::/96 next-hop \u0026lt;Your machines IP\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"final-verification-of-jool\"\u003eFinal verification of Jool\u003c/h4\u003e\n\u003cp\u003eLet\u0026rsquo;s try running some traffic through the NAT64 router and see if it works. To start out with, let\u0026rsquo;s use ping to test this.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# From a host on the Lan side NOT THE NAT64 ROUTER ITSELF, ping 1.1.1.1 though the nat64 prefix.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e➜  ~ ping 64:ff9b::1.1.1.1 \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePING 64:ff9b::1.1.1.1\u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003e64:ff9b::101:101\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e56\u003c/span\u003e data bytes\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e5.67 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e6.71 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e7.13 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e8.18 ms\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"adding-dns64\"\u003eAdding DNS64\u003c/h3\u003e\n\u003cp\u003eWhile some hosts might automaticly discover the NAT64 router, it is unlikely. Therefore we need a DNS64 server.\nThis might be something i built in the future, but for now i will just use a publicly avalible one. These servers assume you use 64:ff9b::/96 as your NAT64 prefix, so this is not an option if you are using a different prefix.\u003c/p\u003e\n\u003cp\u003eHere is a list of some public DNS64 servers:\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eName\u003c/th\u003e\n          \u003cth\u003eAddress\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eGoogle - Primary\u003c/td\u003e\n          \u003ctd\u003e2001:4860:4860::6464\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eGoogle - Secondary\u003c/td\u003e\n          \u003ctd\u003e2001:4860:4860::64\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCloudflare - Primary\u003c/td\u003e\n          \u003ctd\u003e2606:4700:4700::64\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCloudflare - Secondary\u003c/td\u003e\n          \u003ctd\u003e2606:4700:4700::6400\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eI will be using Cloudflares in my network.\u003c/p\u003e\n\u003cp\u003eAgain, this step depends on what router you are using (and your address alocation techniques). But you want to either update your router advertisements, or DHCPv6 to announce two DNS64 servers.\u003c/p\u003e\n\u003cp\u003eOnce you have done that, you can use curl to test that it works\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecurl -6 v4.ipv6test.app\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eDiagram\u003c/li\u003e\n\u003cli\u003eAbout the machine\u003c/li\u003e\n\u003cli\u003eSetting up Jool\u003c/li\u003e\n\u003cli\u003eSetting up BGP\u003c/li\u003e\n\u003cli\u003eVerification\nFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eIn theroy installing Jool on Ubuntu should be very easy, it is included in the default APT repository, so all you should need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI would recormend you try the above mentioned route, but as of writing, it doesn\u0026rsquo;t work. The version of Jool in the repo is too old, and does not support the current kernel version for Ubuntu 24.04 LTS. So here is the manuel way\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Find the newest versions here: https://github.com/NICMx/Jool/releases\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Download kernel module and tools\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install kernel headers\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapt install linux-headers-\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003euname -r\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install the packages\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo dpkg -i jool-*.deb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"routing\"\u003eRouting\u003c/h4\u003e\n\u003cp\u003eGiven this guide assumes the NAT64 router is outside the normal path of traffic, we need to route the NAT64 prefix towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. For simplicity I have decided to use Static routing.\u003c/p\u003e\n\u003cp\u003eI unfortunly can\u0026rsquo;t tell you exactly how to configure this routing, due to it being slightly diffrent on each router OS. But here is an example from Vyos:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset protocols static route6 64:ff9b::/96 next-hop \u0026lt;Your machines IP\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"final-verification-of-jool\"\u003eFinal verification of Jool\u003c/h4\u003e\n\u003cp\u003eLet\u0026rsquo;s try running some traffic through the NAT64 router and see if it works. To start out with, let\u0026rsquo;s use ping to test this.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# From a host on the Lan side NOT THE NAT64 ROUTER ITSELF, ping 1.1.1.1 though the nat64 prefix.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e➜  ~ ping 64:ff9b::1.1.1.1 \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePING 64:ff9b::1.1.1.1\u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003e64:ff9b::101:101\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e56\u003c/span\u003e data bytes\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e5.67 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e6.71 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e7.13 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e8.18 ms\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"adding-dns64\"\u003eAdding DNS64\u003c/h3\u003e\n\u003cp\u003eWhile some hosts might automaticly discover the NAT64 router, it is unlikely. Therefore we need a DNS64 server.\nThis might be something i built in the future, but for now i will just use a publicly avalible one. These servers assume you use 64:ff9b::/96 as your NAT64 prefix, so this is not an option if you are using a different prefix.\u003c/p\u003e\n\u003cp\u003eHere is a list of some public DNS64 servers:\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eName\u003c/th\u003e\n          \u003cth\u003eAddress\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eGoogle - Primary\u003c/td\u003e\n          \u003ctd\u003e2001:4860:4860::6464\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eGoogle - Secondary\u003c/td\u003e\n          \u003ctd\u003e2001:4860:4860::64\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCloudflare - Primary\u003c/td\u003e\n          \u003ctd\u003e2606:4700:4700::64\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCloudflare - Secondary\u003c/td\u003e\n          \u003ctd\u003e2606:4700:4700::6400\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eI will be using Cloudflares in my network.\u003c/p\u003e\n\u003cp\u003eAgain, this step depends on what router you are using (and your address alocation techniques). But you want to either update your router advertisements, or DHCPv6 to announce two DNS64 servers.\u003c/p\u003e\n\u003cp\u003eOnce you have done that, you can use curl to test that it works\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e➜  ~ curl -6 -v v4.ipv6test.app\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e*   Trying 64:ff9b::12ad:57b:80...\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e* Connected to v4.ipv6test.app \u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003e64:ff9b::12ad:57b\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e port \u003cspan style=\"color:#ae81ff\"\u003e80\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#0)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026gt; GET / HTTP/1.1\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026gt; Host: v4.ipv6test.app\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026gt; User-Agent: curl/7.81.0\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026gt; Accept: */*\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026gt; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e* Mark bundle as not supporting multiuse\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; HTTP/1.1 \u003cspan style=\"color:#ae81ff\"\u003e200\u003c/span\u003e OK\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Server: CloudFront\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Date: Sun, \u003cspan style=\"color:#ae81ff\"\u003e13\u003c/span\u003e Jul \u003cspan style=\"color:#ae81ff\"\u003e2025\u003c/span\u003e 15:57:01 GMT\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Content-Type: text/plain\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Content-Length: \u003cspan style=\"color:#ae81ff\"\u003e13\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Connection: keep-alive\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Cache-Control: no-store\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; X-Cache: FunctionGeneratedResponse from cloudfront\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Via: 1.1 acf2dd107c5d6d9bebe3457b4f66431e.cloudfront.net \u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003eCloudFront\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; X-Amz-Cf-Pop: CPH50-P1\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Alt-Svc: h3\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;:443\u0026#34;\u003c/span\u003e; ma\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e86400\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; X-Amz-Cf-Id: EnXaGh0GuNnz9vjirNdrCtDnTTj5grn7vGoMJiJJu3CE9rdNIYxlpQ\u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; X-XSS-Protection: 1; mode\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eblock\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Referrer-Policy: no-referrer\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Content-Security-Policy: script-src \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;self\u0026#39;\u003c/span\u003e; frame-ancestors \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;none\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; X-Content-Type-Options: nosniff\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Permissions-Policy: geolocation\u003cspan style=\"color:#f92672\"\u003e=()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e* Connection \u003cspan style=\"color:#75715e\"\u003e#0 to host v4.ipv6test.app left intact\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ey.z.x.c%  \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eAs you can see in the top, this Ipv4 only site is accessed over ipv6 though NAT64. At the bottom we can see an IPv4 address (redacted), this is Jools outside address (or atleasted NAT\u0026rsquo;ed) outside address. So from the perspective of the server, we are an ipv4 client. But we are really using IPv6 on our end. This is exactly what we wanted to see.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eThis post has been a bit long and I hope you enjoyed it as much as I did writing it. We have covered what NAT64 is, what deployment options we have, and how to deploy it. I hope this will help you in your homelab journey, and hope you take the time to deploy ipv6 mostly in your own network. IPv6 is the future, and way too few people understand it yet.\u003c/p\u003e\n","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cp\u003eFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container. This does not require a lot of resources\u003c/p\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eIn theroy installing Jool on Ubuntu should be very easy, it is included in the default APT repository, so all you should need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI would recormend you try the above mentioned route, but as of writing, it doesn\u0026rsquo;t work. The version of Jool in the repo is too old, and does not support the current kernel version for Ubuntu 24.04 LTS. So here is the manuel way\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Find the newest versions here: https://github.com/NICMx/Jool/releases\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Download kernel module and tools\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install kernel headers\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapt install linux-headers-\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003euname -r\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install the packages\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo dpkg -i jool-*.deb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"routing\"\u003eRouting\u003c/h4\u003e\n\u003cp\u003eGiven this guide assumes the NAT64 router is outside the normal path of traffic, we need to route the NAT64 prefix towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. For simplicity I have decided to use Static routing.\u003c/p\u003e\n\u003cp\u003eI unfortunly can\u0026rsquo;t tell you exactly how to configure this routing, due to it being slightly diffrent on each router OS. But here is an example from Vyos:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset protocols static route6 64:ff9b::/96 next-hop \u0026lt;Your machines IP\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"final-verification-of-jool\"\u003eFinal verification of Jool\u003c/h4\u003e\n\u003cp\u003eLet\u0026rsquo;s try running some traffic through the NAT64 router and see if it works. To start out with, let\u0026rsquo;s use ping to test this.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# From a host on the Lan side NOT THE NAT64 ROUTER ITSELF, ping 1.1.1.1 though the nat64 prefix.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e➜  ~ ping 64:ff9b::1.1.1.1 \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePING 64:ff9b::1.1.1.1\u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003e64:ff9b::101:101\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e56\u003c/span\u003e data bytes\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e5.67 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e6.71 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e7.13 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e8.18 ms\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"adding-dns64\"\u003eAdding DNS64\u003c/h3\u003e\n\u003cp\u003eWhile some hosts might automaticly discover the NAT64 router, it is unlikely. Therefore we need a DNS64 server.\nThis might be something i built in the future, but for now i will just use a publicly avalible one. These servers assume you use 64:ff9b::/96 as your NAT64 prefix, so this is not an option if you are using a different prefix.\u003c/p\u003e\n\u003cp\u003eHere is a list of some public DNS64 servers:\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eName\u003c/th\u003e\n          \u003cth\u003eAddress\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eGoogle - Primary\u003c/td\u003e\n          \u003ctd\u003e2001:4860:4860::6464\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eGoogle - Secondary\u003c/td\u003e\n          \u003ctd\u003e2001:4860:4860::64\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCloudflare - Primary\u003c/td\u003e\n          \u003ctd\u003e2606:4700:4700::64\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCloudflare - Secondary\u003c/td\u003e\n          \u003ctd\u003e2606:4700:4700::6400\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eI will be using Cloudflares in my network.\u003c/p\u003e\n\u003cp\u003eAgain, this step depends on what router you are using (and your address alocation techniques). But you want to either update your router advertisements, or DHCPv6 to announce two DNS64 servers.\u003c/p\u003e\n\u003cp\u003eOnce you have done that, you can use curl to test that it works\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e➜  ~ curl -6 -v v4.ipv6test.app\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e*   Trying 64:ff9b::12ad:57b:80...\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e* Connected to v4.ipv6test.app \u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003e64:ff9b::12ad:57b\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e port \u003cspan style=\"color:#ae81ff\"\u003e80\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#0)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026gt; GET / HTTP/1.1\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026gt; Host: v4.ipv6test.app\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026gt; User-Agent: curl/7.81.0\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026gt; Accept: */*\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026gt; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e* Mark bundle as not supporting multiuse\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; HTTP/1.1 \u003cspan style=\"color:#ae81ff\"\u003e200\u003c/span\u003e OK\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Server: CloudFront\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Date: Sun, \u003cspan style=\"color:#ae81ff\"\u003e13\u003c/span\u003e Jul \u003cspan style=\"color:#ae81ff\"\u003e2025\u003c/span\u003e 15:57:01 GMT\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Content-Type: text/plain\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Content-Length: \u003cspan style=\"color:#ae81ff\"\u003e13\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Connection: keep-alive\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Cache-Control: no-store\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; X-Cache: FunctionGeneratedResponse from cloudfront\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Via: 1.1 acf2dd107c5d6d9bebe3457b4f66431e.cloudfront.net \u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003eCloudFront\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; X-Amz-Cf-Pop: CPH50-P1\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Alt-Svc: h3\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;:443\u0026#34;\u003c/span\u003e; ma\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e86400\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; X-Amz-Cf-Id: EnXaGh0GuNnz9vjirNdrCtDnTTj5grn7vGoMJiJJu3CE9rdNIYxlpQ\u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; X-XSS-Protection: 1; mode\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eblock\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Referrer-Policy: no-referrer\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Content-Security-Policy: script-src \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;self\u0026#39;\u003c/span\u003e; frame-ancestors \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;none\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; X-Content-Type-Options: nosniff\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Permissions-Policy: geolocation\u003cspan style=\"color:#f92672\"\u003e=()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e* Connection \u003cspan style=\"color:#75715e\"\u003e#0 to host v4.ipv6test.app left intact\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ey.z.x.c%  \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eAs you can see in the top, this Ipv4 only site is accessed over ipv6 though NAT64. At the bottom we can see an IPv4 address (redacted), this is Jools outside address (or atleasted NAT\u0026rsquo;ed) outside address. So from the perspective of the server, we are an ipv4 client. But we are really using IPv6 on our end. This is exactly what we wanted to see.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eThis post has been a bit long and I hope you enjoyed it as much as I did writing it. We have covered what NAT64 is, what deployment options we have, and how to deploy it. I hope this will help you in your homelab journey, and hope you take the time to deploy ipv6 mostly in your own network. IPv6 is the future, and way too few people understand it yet.\u003c/p\u003e\n","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cp\u003eFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container. This does not require a lot of resources I have speced mine with 1G of RAM and 1 Core. This seems to be enough for my needs.\u003c/p\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eIn theroy installing Jool on Ubuntu should be very easy, it is included in the default APT repository, so all you should need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI would recormend you try the above mentioned route, but as of writing, it doesn\u0026rsquo;t work. The version of Jool in the repo is too old, and does not support the current kernel version for Ubuntu 24.04 LTS. So here is the manuel way\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Find the newest versions here: https://github.com/NICMx/Jool/releases\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Download kernel module and tools\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install kernel headers\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapt install linux-headers-\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003euname -r\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install the packages\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo dpkg -i jool-*.deb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"routing\"\u003eRouting\u003c/h4\u003e\n\u003cp\u003eGiven this guide assumes the NAT64 router is outside the normal path of traffic, we need to route the NAT64 prefix towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. For simplicity I have decided to use Static routing.\u003c/p\u003e\n\u003cp\u003eI unfortunly can\u0026rsquo;t tell you exactly how to configure this routing, due to it being slightly diffrent on each router OS. But here is an example from Vyos:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset protocols static route6 64:ff9b::/96 next-hop \u0026lt;Your machines IP\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"final-verification-of-jool\"\u003eFinal verification of Jool\u003c/h4\u003e\n\u003cp\u003eLet\u0026rsquo;s try running some traffic through the NAT64 router and see if it works. To start out with, let\u0026rsquo;s use ping to test this.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# From a host on the Lan side NOT THE NAT64 ROUTER ITSELF, ping 1.1.1.1 though the nat64 prefix.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e➜  ~ ping 64:ff9b::1.1.1.1 \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePING 64:ff9b::1.1.1.1\u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003e64:ff9b::101:101\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e56\u003c/span\u003e data bytes\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e5.67 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e6.71 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e7.13 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e8.18 ms\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"adding-dns64\"\u003eAdding DNS64\u003c/h3\u003e\n\u003cp\u003eWhile some hosts might automaticly discover the NAT64 router, it is unlikely. Therefore we need a DNS64 server.\nThis might be something i built in the future, but for now i will just use a publicly avalible one. These servers assume you use 64:ff9b::/96 as your NAT64 prefix, so this is not an option if you are using a different prefix.\u003c/p\u003e\n\u003cp\u003eHere is a list of some public DNS64 servers:\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eName\u003c/th\u003e\n          \u003cth\u003eAddress\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eGoogle - Primary\u003c/td\u003e\n          \u003ctd\u003e2001:4860:4860::6464\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eGoogle - Secondary\u003c/td\u003e\n          \u003ctd\u003e2001:4860:4860::64\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCloudflare - Primary\u003c/td\u003e\n          \u003ctd\u003e2606:4700:4700::64\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCloudflare - Secondary\u003c/td\u003e\n          \u003ctd\u003e2606:4700:4700::6400\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eI will be using Cloudflares in my network.\u003c/p\u003e\n\u003cp\u003eAgain, this step depends on what router you are using (and your address alocation techniques). But you want to either update your router advertisements, or DHCPv6 to announce two DNS64 servers.\u003c/p\u003e\n\u003cp\u003eOnce you have done that, you can use curl to test that it works\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e➜  ~ curl -6 -v v4.ipv6test.app\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e*   Trying 64:ff9b::12ad:57b:80...\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e* Connected to v4.ipv6test.app \u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003e64:ff9b::12ad:57b\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e port \u003cspan style=\"color:#ae81ff\"\u003e80\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#0)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026gt; GET / HTTP/1.1\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026gt; Host: v4.ipv6test.app\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026gt; User-Agent: curl/7.81.0\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026gt; Accept: */*\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026gt; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e* Mark bundle as not supporting multiuse\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; HTTP/1.1 \u003cspan style=\"color:#ae81ff\"\u003e200\u003c/span\u003e OK\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Server: CloudFront\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Date: Sun, \u003cspan style=\"color:#ae81ff\"\u003e13\u003c/span\u003e Jul \u003cspan style=\"color:#ae81ff\"\u003e2025\u003c/span\u003e 15:57:01 GMT\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Content-Type: text/plain\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Content-Length: \u003cspan style=\"color:#ae81ff\"\u003e13\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Connection: keep-alive\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Cache-Control: no-store\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; X-Cache: FunctionGeneratedResponse from cloudfront\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Via: 1.1 acf2dd107c5d6d9bebe3457b4f66431e.cloudfront.net \u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003eCloudFront\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; X-Amz-Cf-Pop: CPH50-P1\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Alt-Svc: h3\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;:443\u0026#34;\u003c/span\u003e; ma\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e86400\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; X-Amz-Cf-Id: EnXaGh0GuNnz9vjirNdrCtDnTTj5grn7vGoMJiJJu3CE9rdNIYxlpQ\u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; X-XSS-Protection: 1; mode\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eblock\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Referrer-Policy: no-referrer\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Content-Security-Policy: script-src \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;self\u0026#39;\u003c/span\u003e; frame-ancestors \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;none\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; X-Content-Type-Options: nosniff\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Permissions-Policy: geolocation\u003cspan style=\"color:#f92672\"\u003e=()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e* Connection \u003cspan style=\"color:#75715e\"\u003e#0 to host v4.ipv6test.app left intact\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ey.z.x.c%  \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eAs you can see in the top, this Ipv4 only site is accessed over ipv6 though NAT64. At the bottom we can see an IPv4 address (redacted), this is Jools outside address (or atleasted NAT\u0026rsquo;ed) outside address. So from the perspective of the server, we are an ipv4 client. But we are really using IPv6 on our end. This is exactly what we wanted to see.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eThis post has been a bit long and I hope you enjoyed it as much as I did writing it. We have covered what NAT64 is, what deployment options we have, and how to deploy it. I hope this will help you in your homelab journey, and hope you take the time to deploy ipv6 mostly in your own network. IPv6 is the future, and way too few people understand it yet.\u003c/p\u003e\n","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"},{"content":"\u003cp\u003eAs discussed in \u003cem\u003e\u003cstrong\u003e\u003ca href=\"/posts/ipv6-mostly-home-intro/\"\u003ethe previous post\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e, I am currently making some modifications to my homelab. As a part of this process, I am looking at NAT64 solutions again. I am currently running Tayga on OpnSense, but want to move to NAT64 with a dedicated VM. This post will be going through what NAT64 is, how clients interact with it, a comparison of different implementations and finally setting up my chosen implementation.\u003c/p\u003e\n\u003ch2 id=\"what-is-nat64-and-why-do-we-need-it\"\u003eWhat is NAT64 and why do we need it?\u003c/h2\u003e\n\u003cp\u003eWe need NAT64 in IPv6 mostly and IPv6 only networks because there are still many sites and services on the internet that don\u0026rsquo;t support IPv6. NAT64 solves this problem by mapping every single IPv4 address to a unique IPv6 address, which can be used for communication with those addresses.\u003c/p\u003e\n\u003cp\u003eThis doesn\u0026rsquo;t magically fix client devices that don\u0026rsquo;t support IPv6, but it enables devices with IPv6 support to start going IPv6 only. Mobile devices, and some desktop operating systems (primarily macOS) support IPv6 only operations particularly well, due to having built-in CLAT implementations. However, we will dive deeper into this later.\u003c/p\u003e\n\u003ch2 id=\"how-does-nat64-work\"\u003eHow does NAT64 work?\u003c/h2\u003e\n\u003cp\u003eAll NAT64 implementations map an IPv6 address into a /96 IPv6 prefix by taking every single bit of the IPv4 address and adding it to the end of the IPv6 address. This means that for example, an IPv4 address \u0026lsquo;1.1.1.1\u0026rsquo; could become \u0026lsquo;64:ff9b::101:101\u0026rsquo;, or \u0026lsquo;96.7.128.175\u0026rsquo; becomes \u0026lsquo;64:ff9b::6007:80af\u0026rsquo;.\u003c/p\u003e\n\u003cp\u003eBut where does the 64:ff9b:: come from? Well, you can technically use any /96 IPv6 prefix, but 64:ff9b::/96 is reserved to NAT64. Using 64:ff9b::/96 does have some pros and cons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf you want to use publicly avalible DNS64 services, this is the prefix they assume your NAT64 implementation will be using.\u003c/li\u003e\n\u003cli\u003eIt is obvious that traffic is going through NAT64 if you see an 64:ff9b::/96 address.\u003c/li\u003e\n\u003cli\u003eSome NAT64 implementations might not allow translating traffic to RFC1918 destinations, if you are using 64:ff9b::/96\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere can be some diffrences between NAT64 implementations, but we will look more at that in the comparison section below. For homelab purposes i would also argue it makes quite a diffrence if you are managing the NAT64 software directly, or if you are using it as part of an intigrated solution like running NAT64 in OpnSense.\u003c/p\u003e\n\u003ch2 id=\"client-interaction-with-nat64\"\u003eClient interaction with NAT64\u003c/h2\u003e\n\u003cp\u003eIt might be worth briefly looking at how clients interact with NAT64 before looking at the solutions themself. The two main ways are DNS64 and CLAT (also known as 464XLAT), which are not mutually exclusive, but can be used in combination.\u003c/p\u003e\n\u003ch3 id=\"dns64\"\u003eDNS64\u003c/h3\u003e\n\u003cp\u003eDNS64 essentially works by lying to the client, The DNS server sends A and AAAA queries for a given domain. If no AAAA record is found, it maps the A record address into a NAT64 address, for this reason it is very important that the DNS64 server knows the correct NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/DNS64_flow.png\" alt=\"DNS64\"\u003e\u003c/p\u003e\n\u003cp\u003eThe advantage of using DNS64 is quite clear, it doesn\u0026rsquo;t require any changes to your clients. But there are unfortunately a few drawbacks:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf used standalone without CLAT on the clients, it doesn\u0026rsquo;t offer any fallback in case a service has a AAAA record, but the IPv6 implementation of the site for some reason doesn\u0026rsquo;t work. To be fair, this is not a flaw in DNS64 itself, but just a consequence of purely relying on DNS64.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t offer any way of translating IPv4 littrals. While generally not a huge problem, it is a problem in some cases, most notably Discord voice chat.\u003c/li\u003e\n\u003cli\u003eIf your endpoints are doing DNSSEC validation, it will detect that the DNS server is lying to you and reject the response.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"464xlat\"\u003e464XLAT\u003c/h3\u003e\n\u003cp\u003e464XLAT introduces a new component, a Customer site translater called CLAT. The CLAT is most often located on the endpoint device itself, but it doesn\u0026rsquo;t have to be. If as an example you have 5G router on an IPv6 Only mobile network, you probably have a CLAT function built into your router. CLAT essentially just allows the translation of IPv4 packets into IPv6 packets using the NAT64 prefix.\n\u003cimg src=\"/images/content/ipv6-series/464xlat.png\" alt=\"464XLAT\"\u003e\u003c/p\u003e\n\u003cp\u003eThe pros of this is that IPv4 works no matter if you have DNSSEC, IPv4 littrals, or whatever else. The cons are that it requires a new component usually located on the endpoint device itself.\nMobile devices generally have very good CLAT implementations, apple have also included the Iphones CLAT implementation in macOS. Microsoft have commited to CLAT for all network types in Windows 11, but they commited to that over a year ago, and we haven\u0026rsquo;t heard anything since.\u003c/p\u003e\n\u003cp\u003eBut how do CLAT implementations even know what NAT64 prefix to use? There are generally two ways of doing this.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first and preferred way is to use PREF64 router advertisements. This option needs to be implemented per endpoint network, but it enables the router to inform the client about the NAT64 prefix when announcing the IPv6 router information.\u003c/li\u003e\n\u003cli\u003eAnother way is using DNS64. This requires the client to lookup a AAAA record for ipv4only.arpa. Per RFC7050 the response for ipv4only.arpa should be 192.0.0.170/192.0.0.171. So AAAA response would indicate NAT64 is implemted. The NAT64 prefix is found by taking the first 96 bits of the IPv6 address in the response, and using that as the NAT64 prefix. It is worth noting that the IETF is working on deprecating this method, recormending the use of PREF64 instead.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"comparing-nat64-implementations\"\u003eComparing NAT64 implementations\u003c/h3\u003e\n\u003cp\u003eI will focusing mostly on NAT64 implementations that are free, and easy to implement. So yes you could ask Cisco/F5/Juniper/etc for a NAT64 implementation, solution. But not everyone has access to that.\u003c/p\u003e\n\u003cp\u003eI do however have a cisco router in my homelab, so i will include that just because i could use it.\u003c/p\u003e\n\u003ch4 id=\"tayga\"\u003eTayga\u003c/h4\u003e\n\u003cp\u003eI am currently using Tayga inside OpnSense and it has worked fine for me. From what i remember this was generally the recormended solution back when i last researched NAT64. It seems like it\u0026rsquo;s not the best option for performance, and that it has had some problems with lacking maintence.\u003c/p\u003e\n\u003cp\u003eEarlier in 2025 some new life was given to Tayga, in the form of Andrew Palardy being the new maintainer (Checkout his \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.youtube.com/@apalrdsadventures\"\u003eyoutube channel\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e if you like this kind of content)\u003c/p\u003e\n\u003cp\u003eIt is ofcourse posible to setup a VM, and just run Tayga on any Linux server, but tayga is also the NAT64 option for OpnSense, and PfSense.\u003c/p\u003e\n\u003ch4 id=\"jool\"\u003eJool\u003c/h4\u003e\n\u003cp\u003eJool seems to be a newer better performing option, development seems to be slow but still existing.\nUnlike Tayga, it runs as a kernel module. This could be why the performance is much better.\u003c/p\u003e\n\u003cp\u003eI haven\u0026rsquo;t done any performance testing but Nico Schottelius did a \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://ripe85.ripe.net/presentations/78-ripe85-open-source-nat64.pdf\"\u003epresentation at RIPE85\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e and found Jool to perform more than twice as fast as Tayga, but I haven\u0026rsquo;t tested it myself yet.\u003c/p\u003e\n\u003cp\u003eIf you want an out of the box solution using Jool, it seems like Jool is the built in NAT64 option for VYOS.\u003c/p\u003e\n\u003ch4 id=\"cisco-ios-xe\"\u003eCisco IOS XE\u003c/h4\u003e\n\u003cp\u003eI happen to have a fairly modern Cisco router in my lab, so I wanted to look at if i could use that. I would probably not recormend going out to buy a physical router just to use it for NAT64.\u003c/p\u003e\n\u003cp\u003eThe main pro for me is that it is something that is more likely to see in a production network. Obivoiusly when running a production network, vendor support is a very important component. It also seems very easy to configure, and i am sure it would work fine.\nA drawback for me is power consumption. I currently don\u0026rsquo;t have any other reason to run that router 24/7, so locating NAT64 on it, would add a new source of power draw to my homelab.\u003c/p\u003e\n\u003ch2 id=\"my-setup\"\u003eMy setup\u003c/h2\u003e\n\u003cp\u003eBased on above mentioned options, i have decided to use Jool. The performance is defendly nice, but besides that I just wanted to try something new. As mentioned, I have experince with Tayga, but what\u0026rsquo;s the point in having a homelab if you don\u0026rsquo;t try something new and have fun with it.\u003c/p\u003e\n\u003ch3 id=\"setting-up-jool-on-ubuntu-2404-lts\"\u003eSetting up Jool on Ubuntu 24.04 LTS\u003c/h3\u003e\n\u003cp\u003eFirst start out with a clean ubuntu machine, given that Jool runs as a kernel module, I would highly recormend going with a full VM, instead of trying to make this work on an LXC container. This does not require a lot of resources I have speced mine with 1G of RAM and 1 Core. This seems to be enough for my needs.\u003c/p\u003e\n\u003ch4 id=\"installing-jool\"\u003eInstalling Jool\u003c/h4\u003e\n\u003cp\u003eIn theroy installing Jool on Ubuntu should be very easy, it is included in the default APT repository, so all you should need to do is install it from there.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Update package repo\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt update\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install Jool\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo apt install jool-dkms jool-tools -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eI would recormend you try the above mentioned route, but as of writing, it doesn\u0026rsquo;t work. The version of Jool in the repo is too old, and does not support the current kernel version for Ubuntu 24.04 LTS. So here is the manuel way\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Find the newest versions here: https://github.com/NICMx/Jool/releases\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Download kernel module and tools\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/NICMx/Jool/releases/download/v4.1.14/jool-dkms_4.1.14-1_all.deb \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install kernel headers\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapt install linux-headers-\u003cspan style=\"color:#66d9ef\"\u003e$(\u003c/span\u003euname -r\u003cspan style=\"color:#66d9ef\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Install the packages\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo dpkg -i jool-*.deb\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eGiven that Jool runs as a kernel module, we need to load it. This example both loads it now, and makes the change persistant. But I would recormend rebooting your machine after this step, just to make sure the persistance works.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Add Jool to list of modules loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo su -c \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;echo jool \u0026gt; /etc/modules-load.d/jool.conf\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Restart systemd\u0026#39;s load modules service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl restart systemd-modules-load\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the module has been loaded\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elsmod | grep jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool                   \u003cspan style=\"color:#ae81ff\"\u003e16384\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejool_common           \u003cspan style=\"color:#ae81ff\"\u003e319488\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv6         \u003cspan style=\"color:#ae81ff\"\u003e24576\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enf_defrag_ipv4         \u003cspan style=\"color:#ae81ff\"\u003e12288\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e jool\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex_tables               \u003cspan style=\"color:#ae81ff\"\u003e65536\u003c/span\u003e  \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e jool,ip_tables\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"creating-a-service\"\u003eCreating a service\u003c/h4\u003e\n\u003cp\u003eNow let\u0026rsquo;s create a service file for Jool to start on bootup. I have created a file called /etc/systemd/system/jool.service with the following content:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eUnit\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDescription\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eJool NAT64\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eService\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eType\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eoneshot\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eExecStart\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e/usr/bin/jool instance add --netfilter --pool6 64:ff9b::/96\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eInstall\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWantedBy\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003emulti-user.target\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eLet\u0026rsquo;s enable and start the service:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Reload services\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl daemon-reload\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Enable the service\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl enable --now jool.service\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify the service is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo systemctl status jool.service\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"verifying-jool\"\u003eVerifying Jool\u003c/h4\u003e\n\u003cp\u003eWe can verify that the service is working correctly by checking the known instances and status of Jool:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# List known instances\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance display\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Verify Jool is running\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool instance status\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# Show Jool global config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esudo jool global display\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"routing\"\u003eRouting\u003c/h4\u003e\n\u003cp\u003eGiven this guide assumes the NAT64 router is outside the normal path of traffic, we need to route the NAT64 prefix towards the machine. You can achive this in multiple ways, but the most obivious would be BGP or static routing. For simplicity I have decided to use Static routing.\u003c/p\u003e\n\u003cp\u003eI unfortunly can\u0026rsquo;t tell you exactly how to configure this routing, due to it being slightly diffrent on each router OS. But here is an example from Vyos:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset protocols static route6 64:ff9b::/96 next-hop \u0026lt;Your machines IP\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch4 id=\"final-verification-of-jool\"\u003eFinal verification of Jool\u003c/h4\u003e\n\u003cp\u003eLet\u0026rsquo;s try running some traffic through the NAT64 router and see if it works. To start out with, let\u0026rsquo;s use ping to test this.\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# From a host on the Lan side NOT THE NAT64 ROUTER ITSELF, ping 1.1.1.1 though the nat64 prefix.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e➜  ~ ping 64:ff9b::1.1.1.1 \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ePING 64:ff9b::1.1.1.1\u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003e64:ff9b::101:101\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e56\u003c/span\u003e data bytes\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e5.67 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e6.71 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e7.13 ms\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ae81ff\"\u003e64\u003c/span\u003e bytes from 64:ff9b::101:101: icmp_seq\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e ttl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e51\u003c/span\u003e time\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e8.18 ms\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"adding-dns64\"\u003eAdding DNS64\u003c/h3\u003e\n\u003cp\u003eWhile some hosts might automaticly discover the NAT64 router, it is unlikely. Therefore we need a DNS64 server.\nThis might be something i built in the future, but for now i will just use a publicly avalible one. These servers assume you use 64:ff9b::/96 as your NAT64 prefix, so this is not an option if you are using a different prefix.\u003c/p\u003e\n\u003cp\u003eHere is a list of some public DNS64 servers:\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eName\u003c/th\u003e\n          \u003cth\u003eAddress\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eGoogle - Primary\u003c/td\u003e\n          \u003ctd\u003e2001:4860:4860::6464\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eGoogle - Secondary\u003c/td\u003e\n          \u003ctd\u003e2001:4860:4860::64\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCloudflare - Primary\u003c/td\u003e\n          \u003ctd\u003e2606:4700:4700::64\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eCloudflare - Secondary\u003c/td\u003e\n          \u003ctd\u003e2606:4700:4700::6400\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eI will be using Cloudflares in my network.\u003c/p\u003e\n\u003cp\u003eAgain, this step depends on what router you are using (and your address alocation techniques). But you want to either update your router advertisements, or DHCPv6 to announce two DNS64 servers.\u003c/p\u003e\n\u003cp\u003eOnce you have done that, you can use curl to test that it works\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e➜  ~ curl -6 -v v4.ipv6test.app\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e*   Trying 64:ff9b::12ad:57b:80...\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e* Connected to v4.ipv6test.app \u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003e64:ff9b::12ad:57b\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e port \u003cspan style=\"color:#ae81ff\"\u003e80\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003e\u003cspan style=\"color:#75715e\"\u003e#0)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026gt; GET / HTTP/1.1\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026gt; Host: v4.ipv6test.app\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026gt; User-Agent: curl/7.81.0\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026gt; Accept: */*\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026gt; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e* Mark bundle as not supporting multiuse\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; HTTP/1.1 \u003cspan style=\"color:#ae81ff\"\u003e200\u003c/span\u003e OK\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Server: CloudFront\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Date: Sun, \u003cspan style=\"color:#ae81ff\"\u003e13\u003c/span\u003e Jul \u003cspan style=\"color:#ae81ff\"\u003e2025\u003c/span\u003e 15:57:01 GMT\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Content-Type: text/plain\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Content-Length: \u003cspan style=\"color:#ae81ff\"\u003e13\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Connection: keep-alive\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Cache-Control: no-store\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; X-Cache: FunctionGeneratedResponse from cloudfront\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Via: 1.1 acf2dd107c5d6d9bebe3457b4f66431e.cloudfront.net \u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003eCloudFront\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; X-Amz-Cf-Pop: CPH50-P1\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Alt-Svc: h3\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;:443\u0026#34;\u003c/span\u003e; ma\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e86400\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; X-Amz-Cf-Id: EnXaGh0GuNnz9vjirNdrCtDnTTj5grn7vGoMJiJJu3CE9rdNIYxlpQ\u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; X-XSS-Protection: 1; mode\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eblock\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Referrer-Policy: no-referrer\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Content-Security-Policy: script-src \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;self\u0026#39;\u003c/span\u003e; frame-ancestors \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;none\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; X-Content-Type-Options: nosniff\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; Permissions-Policy: geolocation\u003cspan style=\"color:#f92672\"\u003e=()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026lt; \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e* Connection \u003cspan style=\"color:#75715e\"\u003e#0 to host v4.ipv6test.app left intact\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ey.z.x.c%  \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eAs you can see in the top, this Ipv4 only site is accessed over ipv6 though NAT64. At the bottom we can see an IPv4 address (redacted), this is Jools outside address (or atleasted NAT\u0026rsquo;ed) outside address. So from the perspective of the server, we are an ipv4 client. But we are really using IPv6 on our end. This is exactly what we wanted to see.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eThis post has been a bit long and I hope you enjoyed it as much as I did writing it. We have covered what NAT64 is, what deployment options we have, and how to deploy it. I hope this will help you in your homelab journey, and hope you take the time to deploy ipv6 mostly in your own network. IPv6 is the future, and way too few people understand it yet.\u003c/p\u003e\n","description":"An comparison of diffrent NAT64 options, and an introduction to NAT64 related concepts","image":"/images/content/ipv6-series/DNS64_flow.png","permalink":"http://localhost:1313/posts/nat64-for-the-homelab/","title":"NAT64 for the Homelab"},{"content":"\u003cp\u003eEver since learning about SRv6, I have been interested in testing how SRv6-based VPN services work, especially over an uncontrolled network like the Internet. I happened to have some time and energy to play around with it. This post doesn\u0026rsquo;t describe a production-ready setup; it\u0026rsquo;s just some notes from playing around and figuring out what is possible, how it works, and getting some ideas for future tinkering.\u003c/p\u003e\n\u003ch2 id=\"what-is-segment-routing-and-srv6\"\u003eWhat is Segment routing and SRv6?\u003c/h2\u003e\n\u003cp\u003eSegment routing is a modern approach to directing traffic. It works over either IPv6 or MPLS, and has many interesting features related to redundancy, traffic engineering, and services.\u003c/p\u003e\n\u003cp\u003eSRv6 is the IPv6 flavor of segment routing. Unlike SR-MPLS, it works over any IPv6 data plane (although you might want more). This flexibility makes it possible to extend SRv6-based services over the Internet, which is what we\u0026rsquo;re trying to exploit today. The fact that it\u0026rsquo;s just IPv6 also allows devices that traditionally don\u0026rsquo;t support MPLS to be part of the network, like servers, phones, etc., although this isn\u0026rsquo;t generally seen in the real world.\u003c/p\u003e\n\u003cp\u003eThere are a lot of resources to learn more about segment routing; I would recommend starting with \u003cem\u003e\u003cstrong\u003e\u003ca href=\"https://www.segment-routing.net/\"\u003esegment-routing.net\u003c/a\u003e\u003c/strong\u003e\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"about-the-test-setup\"\u003eAbout the test setup\u003c/h2\u003e\n\u003cp\u003eTo reduce the number of variables, this test network consists of just two routers. I am running VyOS 2025.07.06-0022-rolling on both routers.\u003c/p\u003e\n\u003cp\u003eEach router is connected to a diffrent interface on a router inside my personal AS201911 network. The interfaces on the ISP router is quite simple, just a linknet and a static route pointing to the VPN router.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/srv6-vpn/srv6-vpn.png\" alt=\"image\"\u003e\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003eRouter\u003c/th\u003e\n          \u003cth\u003eWAN Linknet\u003c/th\u003e\n          \u003cth\u003eRouted prefix\u003c/th\u003e\n          \u003cth\u003eRouter ID\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-A\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700a::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:1000::/56\u003c/td\u003e\n          \u003ctd\u003e10.1.1.1\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eVPN-Site-B\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae0:700b::2/64\u003c/td\u003e\n          \u003ctd\u003e2a0e:97c0:ae6:2000::/56\u003c/td\u003e\n          \u003ctd\u003e10.2.2.2\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eBoth routers are part of the ASN 65513, and both have a static ipv6 default route configured towards the ISP Router.\u003c/p\u003e\n\u003ch2 id=\"setting-up-srv6\"\u003eSetting up SRv6\u003c/h2\u003e\n\u003cp\u003eIn a more traditional campus/DC/SP deployment scenario, you would start your SRv6 deployment by deploying an SRv6 capable IGP. However since we are going over the internet, we won\u0026rsquo;t have an IGP. So we are instead starting with BGP.\u003c/p\u003e\n\u003ch3 id=\"setting-up-bgp-between-the-routers\"\u003eSetting up BGP between the routers\u003c/h3\u003e\n\u003cp\u003eBGP is already enable on the routers, so we just need to configure peerings, and srv6 options.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a peer-group, this should be applied to both routers\u003c/p\u003e\n\u003cp\u003eThere is nothing fancy about this configuration, just a simple iBGP peering, with a password and VPN address families.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eset protocols bgp peer-group INTERNAL remote-as internal\nset protocols bgp peer-group INTERNAL password CorrectHorseBatteryStable\nset protocols bgp peer-group INTERNAL address-family ipv4-vpn\nset protocols bgp peer-group INTERNAL address-family ipv6-vpn\nset protocols bgp peer-group INTERNAL capability extended-nexthop\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s create the actual peerings between the two routers using the peer group we created above.\nIn theory we could create a loopback interface inside the routed prefix, and if you have multiple WAN\u0026rsquo;s that might be the best option, but for this example I will just create the BGP peering between the linknet IP\u0026rsquo;s.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols bgp neighbor 2a0e:97c0:ae0:700b::2 peer-group INTERNAL\n\n# On VPN-Site-B\nset protocols bgp neighbor 2a0e:97c0:ae0:700a::2 peer-group INTERNAL\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAnd just like that we have a BGP peering with no routes.\n\u003cimg src=\"/images/content/srv6-vpn/bgp-confirmed.png\" alt=\"bgp-peering\"\u003e\u003c/p\u003e\n\u003ch3 id=\"configuring-srv6\"\u003eConfiguring SRv6\u003c/h3\u003e\n\u003cp\u003eWe need to configure the routed prefix we got from the ISP as a SID, besides that we also need to tell SRv6 what interfaces to use.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by configuring a locator SID for VPN services. For this purpose, i am reserving a prefix inside the routed network.\nA small sidenote, in theory you could create this setup on a router that has a DHCPv6-PD prefix, but given this part of the configuration is static, it could easily break.\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# On VPN-Site-A\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:1001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\n# On VPN-Site-B\nset protocols segment-routing interface eth0\nset protocols segment-routing srv6 locator VPN-SERVICES behavior-usid\nset protocols segment-routing srv6 locator VPN-SERVICES prefix 2a0e:97c0:ae6:2001::/64\nset protocols bgp srv6 locator VPN-SERVICES\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhen a new VPN is created, BGP will take out an address from our VPN-SERVICES prefix and assign that as a destination address for all traffic to the VRF (assuming we want per-vrf \u0026ldquo;label\u0026rdquo;). We can either specify the allocation manually, or let BGP figure it out. I feel trusting in BGPs abilities today, so i will auto assign.\u003c/p\u003e\n\u003ch3 id=\"building-our-first-l3vpn\"\u003eBuilding our first L3VPN\u003c/h3\u003e\n\u003cp\u003eIn theory we should now have a BGP peering, a routed prefix, and an SRv6 locator. So the next step is to try using it.\nIn this step we will create a VRF, and use that VRF on two dummy interfaces to validate connectivity.\u003c/p\u003e\n\u003cp\u003eLet\u0026rsquo;s start by defining the VRF\u003c/p\u003e\n\u003cp\u003eThis configuration starts out defining everything that\u0026rsquo;s the same on both sides.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe linux kernel routing table ID. If you are comming from Cisco or Juniper this is probably new, but just know linux wants a value it can use internally.\u003c/li\u003e\n\u003cli\u003eImport/Export route targets. Note after we have created the targets we need to tell BGP that it should use it.\u003c/li\u003e\n\u003cli\u003eSID, we are telling BGP to auto allocate a SID.\u003c/li\u003e\n\u003cli\u003eFor some reason we need to set system-as and router-id again, i just set it to the same as the global options. I guess this could be a problem if you have a design where your GRT and VPN instance have BGP peerings with eachother.\u003c/li\u003e\n\u003cli\u003eWe are redistributing connected, in this example we are putting the VRF on two dummy interfaces, obiviously if this was a real deployment, we might want to redistribute something diffrent.\u003c/li\u003e\n\u003cli\u003eCreate a dummy interface and assign it to the VRF.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe also have a few unique things per router, this includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIP addresses\u003c/li\u003e\n\u003cli\u003eRouter ID\u003c/li\u003e\n\u003cli\u003eRoute distinguishers.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e# Shared for both routers\nset vrf name L3VPN-1 table 101\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast route-target vpn both 65513:101\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast route-target vpn both 65513:101\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast import vpn\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast export vpn\n\nset vrf name L3VPN-1 protocols bgp sid vpn per-vrf export auto\nset vrf name L3VPN-1 protocols bgp system-as 65513\n\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast redistribute connected\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast redistribute connected\n\nset interfaces dummy dum101 vrf L3VPN-1\nset interfaces dummy dum101 description \u0026#34;L3VPN test interface\u0026#34;\n\n# VPN-Site-A\nset interfaces dummy dum101 address 172.16.10.1/24\nset interfaces dummy dum101 address 2001:db8:1::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.1.1.1:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.1.1.1\n\n# VPN-Site-B\nset interfaces dummy dum101 address 172.16.20.1/24\nset interfaces dummy dum101 address 2001:db8:2::1/64\nset vrf name L3VPN-1 protocols bgp address-family ipv4-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp address-family ipv6-unicast rd vpn export \u0026#39;10.2.2.2:101\u0026#39;\nset vrf name L3VPN-1 protocols bgp parameters router-id 10.2.2.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow let\u0026rsquo;s see if it worked, let\u0026rsquo;s start by checking to see if a locator has been registered\n\u003cimg src=\"/images/content/srv6-vpn/locator-verification.png\" alt=\"locator\"\u003e\nAs you can see a /128 has been taken out, pointing to L3VPN-1 with type End.DT46 meaning this single locator is valid for both ipv4 and ipv6.\u003c/p\u003e\n\u003cp\u003eNow let\u0026rsquo;s check the route table\n\u003cimg src=\"/images/content/srv6-vpn/l3vpn-routes.png\" alt=\"Route table\"\u003e\nAs you can see, we have routes for both V4 and V6. Now for the fun part, let\u0026rsquo;s try to ping it.\n\u003cimg src=\"/images/content/srv6-vpn/ping.png\" alt=\"Ping\"\u003e\nAnd success!!! We now have a working L3VPN over internet.\u003c/p\u003e\n\u003cp\u003eBut how does that look on the wire?\u003c/p\u003e\n\u003cp\u003eAs you can see, matching on Ipv6\u0026rsquo;s next header 43 (source routing) field, we are seeing both the v4 and v6 pings.\nBut as you can also see it\u0026rsquo;s unencrypted, In theory this should be solvable with IPsec, you probably just want to make sure the SRH isn\u0026rsquo;t being encrypted.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-1.png\" alt=\"Wireshark overview\"\u003e\u003c/p\u003e\n\u003cp\u003eWell traffic is flowing from in this case VPN-SITE-B\u0026rsquo;s Linknet address to the SID we saw VPN-SITE-A had reserved for the L3VPN. Inside the packet we can see the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe have a routing header of type segment routing (type 4)\u003c/li\u003e\n\u003cli\u003ewe can see there are 0 segments left, in our case we only have 1 segment, but if you added in traffic engineering, more segments could exist.\u003c/li\u003e\n\u003cli\u003eWe can see our current segment is 2a0e:97c0:ae6:1001:1:: this matches our destination addess. This is exactly how it should be.\u003c/li\u003e\n\u003cli\u003eThe next header is IPIP this indicates the next packet is an IPv4 packet, if we had looked at one of the IPv6 pings, the next header would have been IPv6.\u003c/li\u003e\n\u003cli\u003eWe can see the inner IP header is just a normal header we would expect to see between our two hosts inside the VPN.\n\u003cimg src=\"/images/content/srv6-vpn/wireshark-2.png\" alt=\"Wireshark packet\"\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-can-this-be-used\"\u003eHow can this be used?\u003c/h2\u003e\n\u003cp\u003eThe setup described above with only two sites isn\u0026rsquo;t all that interesting from a usecase perspective. What if we had more sites? What if we wanted to route traffic between all the sites? What if we wanted to steer traffic around the internet in special ways? What if we where using hosts instead of routers?\u003c/p\u003e\n\u003cp\u003eThose are the kind of questions where i think Srv6 becomes very interesting. I might explore how to use SRv6 to create a \u0026ldquo;poor mans SD-WAN\u0026rdquo; solution or something like that in the future.\u003c/p\u003e\n\u003cp\u003eSRv6 is also very intersting from a host/server perspective, the setup above could also be implemted in a container enviorment like K8S to provide a very flexible k8s overlay network. Infact the Cillium project is already kinda doing that,\u003c/p\u003e\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\u003cp\u003eSRv6 is a very powerful technology, while this simple setup didn\u0026rsquo;t acchive anything you couldn\u0026rsquo;t do in a simpler way, i hope it showed what could be posible, and started some thoughts of how we could use SRv6.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/srv6-vpn/srv6-vpn.png","permalink":"http://localhost:1313/posts/experimenting-with-srv6-vpn-over-internet/","title":"Experimenting With Srv6 VPN services Over The Internet"},{"content":"\u003ch2 id=\"why-should-ipv6-be-a-part-of-a-homelab\"\u003eWhy Should IPv6 be a part of a homelab?\u003c/h2\u003e\n\u003cp\u003eI have been a long-time advocate for IPv6. It has been a crucial part of my homelab for years, and through my work at a major Danish ISP, I\u0026rsquo;ve have among other things contributed to enabling and improving IPv6 for many Danish broadband customers.\u003c/p\u003e\n\u003cp\u003eAs I\u0026rsquo;m currently updating and fine-tuning some aspects of my homelab, I thought it would be a good idea to document the process here. This will serve as not only personal documentation but also an introduction for anyone interested in setting up their own IPv6 homelab.\u003c/p\u003e\n\u003cp\u003eBut why should you care about IPv6? Let\u0026rsquo;s take a look at its current usage.\u003c/p\u003e\n\u003cp\u003eFirstly, almost half of all internet traffic is now IPv6. The numbers may vary slightly, but according to reports from Google and Meta, the trend is clear:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/content/ipv6-series/google-stats.png\" alt=\"google ipv6 stats\"\u003e\n\u003ca href=\"https://www.google.com/intl/en/ipv6/statistics.html\"\u003eSource\u003c/a\u003e\n\u003cimg src=\"/images/content/ipv6-series/meta-stats.png\" alt=\"meta ipv6 stats\"\u003e\n\u003ca href=\"https://www.facebook.com/ipv6/?tab=ipv6_total_adoption\"\u003eSource\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eBesides the fact that a large portion of the internet is already using IPv6, there are also pushes from both companies and goverments to move to ipv6. Some of those major pushes include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eApple requires all app store apps to support working in IPv6-only networks. They have required this since 2016.\u003c/li\u003e\n\u003cli\u003eSeveral mobile operators have deployed IPv6-only mobile networks, with 464XLAT being the only way of accessing IPv4 sites. In the West, the most notable example is probably T-Mobile in the US. However, to my knowledge, this approach is also common in developing countries due to IPv4 scarcity.\u003c/li\u003e\n\u003cli\u003eThe US Office of Management and Budget has implemented an IPv6 mandate. In 2023, the US federal government presented a quite ambitious plan for moving to IPv6.\u003c/li\u003e\n\u003cli\u003eChina has mandated that Chinese router manufacturers must enable IPv6 by default in all new routers they sell.\u003c/li\u003e\n\u003cli\u003eMost major cloud providers have started not including public IPv4 addresses for free, thus adding an extra cost for still running IPv4 directly on servers. While this does not force organizations to change, it is a nudge that can be used as a motivator.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOfcourse companies and goverments isn\u0026rsquo;t just pusing for ipv6 for no reason at all. It takes a lot of effort to change, so there needs to be some good reasons behind the change. So here are some of the reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWe are running out of IPv4 address space. Part of this problem is related to the fact that early IPv4 allocation was made in a very shortsighted way; unfortunately, there isn\u0026rsquo;t really a way to change this. (And no Class E or redefining 127.0.0.0/8 won\u0026rsquo;t work.) Unlike many IPv6 supporters, I don\u0026rsquo;t like to say we have run out, but instead say we are running out. While it is true that getting new IPv4 space directly from your RIR is impossible (or close to it), there is still a healthy resale market. So you can get IPv4 space, but supply and demand makes a pure IPv4-only internet an impossibility now due to the amount of things we want connected.\u003c/li\u003e\n\u003cli\u003eSimpler routing and network operations are two benefits of IPv6. This might sound counterintuitive for anyone who has grown up with IPv4 networks, and I do admit it takes some time getting used to. But once you see the beauty in always using /64 netmasks without having to worry about exhaustion, or when you start to appreciate the simplicity of not dealing with NAT when troubleshooting, or realize the simplicity of the (base) IPv6 header compared to IPv4\u0026rsquo;s, you\u0026rsquo;ll understand what I mean. Like all things, there is a learning curve, and the more time you have spent with IPv4, the harder it probably is; but the more you use IPv6, the easier it becomes, and the more you will love it.\u003c/li\u003e\n\u003cli\u003eDecreased latency is another benefit of IPv6. Removing NAT on the internet does decrease latency, especially if your ISP forces you through CGNAT routers placed outside the optimal network path. In some cases, we also see a decreased latency due to cutting out legacy infrastructure that only supports IPv4.\u003c/li\u003e\n\u003cli\u003eEnergy efficiency is also a benefit of IPv6. Kinda the same as latency, removing NAT removes compute cycles to do NAT and decreases power consumption.\u003c/li\u003e\n\u003cli\u003eThe use of extension headers enables several key protocol improvements, including:\n\u003cul\u003e\n\u003cli\u003eRouting header: This allows the source device to specify the path it wants to take through the network. A very cool application of this is SRv6 routing.\u003c/li\u003e\n\u003cli\u003eIPsec header: This allows for encryption and authentication of packets built directly into the IP protocol, instead of as an additional layer like it is in IPv4.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo now that you have a glimpse into why you should care about ipv6, I want to encourage you all to start experimenting with ipv6. Whether you\u0026rsquo;re building networks or developing apps, understanding how to work with ipv6 is essential for the future of networking and computing. With ipv6, we can expect simpler routing, decreased latency, improved energy efficiency, and more. By starting to experiment with ipv6 today, you\u0026rsquo;ll be better equipped to handle the challenges and opportunities that come with it.\u003c/p\u003e\n\u003ch2 id=\"ipv6-mostly-vs-ipv6-only\"\u003eIPv6 Mostly vs IPv6 Only\u003c/h2\u003e\n\u003cp\u003eIt\u0026rsquo;s probably important to start out defining what I am trying to achieve and what some common terms mean.\u003c/p\u003e\n\u003ch3 id=\"ipv6-only\"\u003eIPv6 Only\u003c/h3\u003e\n\u003cp\u003eThis is straightforward; it means that you have access only to an IPv6 network. Unless you understand your devices and applications very well, this might not be a good idea right now.\u003c/p\u003e\n\u003cp\u003eIPv6 only is the ultimate goal, but we aren\u0026rsquo;t there yet. So instead of IPv6 only, most networks are targeting IPv6 mostly as a stepping stone.\u003c/p\u003e\n\u003cp\u003eIpv4 connectivity might still be provided for backwards compatibility through NAT64.\u003c/p\u003e\n\u003ch3 id=\"ipv6-mostly\"\u003eIPv6 Mostly\u003c/h3\u003e\n\u003cp\u003eThis is a defined term; see \u003ca href=\"https://datatracker.ietf.org/doc/draft-ietf-v6ops-6mops/\"\u003eIETF draft-ietf-v6ops-6mops-01\u003c/a\u003e for the full version, but here\u0026rsquo;s the short version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe network must work for IPv6 only clients, dual-stack clients, and IPv4 only clients. The goal is to provide a space for migrating clients towards IPv6 only.\u003c/li\u003e\n\u003cli\u003eThe network must provide a NAT64 solution to the clients; there is no requirement for providing a DNS64 solution.\u003c/li\u003e\n\u003cli\u003eThe network\u0026rsquo;s DHCPv4 server(s) must include DHCP option 108 in responses to clients, indicating to hosts that support IPv6 only that the network also supports IPv6 only. Option 108 essentially lets a device skip getting an IPv4 address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"my-target\"\u003eMy target\u003c/h3\u003e\n\u003cp\u003eMy target for now is IPv6 Mostly, and here\u0026rsquo;s why:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eI own devices that don\u0026rsquo;t support IPv6 or don\u0026rsquo;t support IPv6 only operations.\u003c/li\u003e\n\u003cli\u003eThis is the most common deployment method.\u003c/li\u003e\n\u003cli\u003eIt doesn\u0026rsquo;t limit me from running some devices as IPv6 only for testing purposes.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI have chosen IPv6 mostly because it provides a good balance between being forward-thinking and still supporting backwards compatibility with IPv4 networks. While IPv6 only might be the ultimate goal, IPv6 mostly is a more achievable target that can help pave the way for widespread adoption of IPv6 in the future.\u003c/p\u003e\n\u003ch2 id=\"so-how-do-i-access-ipv4-only-sites\"\u003eSo how do i access ipv4 only sites?\u003c/h2\u003e\n\u003cp\u003eThe short answer is NAT64 + either DNS64 or CLAT. I will dedicate a blog post in the future to NAT64, but here\u0026rsquo;s the short version of what it does. Due to IPv6 having more bits than IPv4, we can cram an ipv4 address into an ipv6 address. We traditionally use 64:ff9b::/96 for this, but there are other options. So let\u0026rsquo;s say you wanted to access 1.1.1.1 via NAT64, instead of sending your packet to 1.1.1.1, you would send it to 64:ff9b::101:101 given that is what the address would be if you took the first 96 bits from 64:ff9b:: and added the 32 bits of 1.1.1.1.\u003c/p\u003e\n\u003cp\u003eBut we are (mostly) not accessing services directly by ipv4 address, so we need to map DNS to this mess, somehow. There are two ways this is done\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDNS64 - This is essentially the DNS server lying to the client, by creating a fake AAAA record though the NAT64 device if no AAAAs exist for that domain. But given the DNS server is lying to the client, DNSSEC doesn\u0026rsquo;t like DNS64. The advantage is that it works on any device that supports IPv6. But it only works for DNS, so any IPv4 literals won\u0026rsquo;t be saved by this. Another indirect consequence of this approach is that sites with AAAA records, but broken ipv6 doesn\u0026rsquo;t have any way to fall back to the ipv4 connectivity.\u003c/li\u003e\n\u003cli\u003eCLAT aka 464XLAT - This works by having code on the device doing the translation, it\u0026rsquo;s typically implemented as a new ip on an existing interface, or new interface entirely. This is very common in mobile devices, and it is (very slowly) getting implemented on desktop devices. The advantage is that this works for both DNS and IPv4 literals, and it doesn\u0026rsquo;t involve changing DNS responses.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"a-short-introduction-to-my-home-network-and-what-i-want-to-do\"\u003eA short introduction to my home network, and what i want to do.\u003c/h2\u003e\n\u003cp\u003eTo say that my home network is unusual would be an understatement. Like a lot of people working in IT, I have a sizable homelab, but unlike most others, I have decided to somewhat separate my lab from the rest of the network. Oh and then there is the small detail that I am running my own publicly routed ASN (AS201911), and though that has a /44 IPv6 allocation.\u003c/p\u003e\n\u003cp\u003eThe following is a diagram from earlier this year, of how I wanted the network to look logically. Some of this isn\u0026rsquo;t implemented, but it gives a picture of the direction I have been going\n\u003cimg src=\"/images/content/ipv6-series/logical-network-diagram-2025.svg\" alt=\"Network diagram\"\u003e\u003c/p\u003e\n\u003cp\u003eI will fully acknowledge that best practice is an unknown concept in this rat\u0026rsquo;s nest of a network. But my goals have never been to create something that made sense; it has been to create something that gave me the flexibility I wanted to do whatever I want with limited impact on other parts of the network. Besides that, I just like BGP, and wanted more BGP in my home network.\u003c/p\u003e\n\u003cp\u003eI don\u0026rsquo;t have a public IPv4 address for my home network, so everything I expose is exposed through IPv6 only, mostly with Cloudflare proxy in front of the service, both to protect the service, and to enable dual-stack access through Cloudflare\u0026rsquo;s proxy service.\u003c/p\u003e\n\u003cp\u003eAll routers you see in the diagram are either OpnSense firewalls or VYOS routers.\u003c/p\u003e\n\u003cp\u003eSo what do I want to do with the network?\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreate a centralized NAT64 service. Right now, the DKNIM-LFW cluster, and DKNIM-HFW clusters are both running NAT64; I would like to centralize this.\u003c/li\u003e\n\u003cli\u003eEnable option 108 on all networks with DHCP. A lot should already have it, but it\u0026rsquo;s not enabled everywhere.\u003c/li\u003e\n\u003cli\u003eExplore running CLAT on Linux servers.\u003c/li\u003e\n\u003cli\u003eExplore options for a permanent IPv6 only or dual-stacked container platform.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"expected-challenges\"\u003eExpected challenges\u003c/h2\u003e\n\u003cp\u003eIf you are starting an IPv6 mostly journey, here are some things to be aware of.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFirstly, there are a few popular services using ipv4 literals, most notably Discord. So if you enable option 108 on a device without CLAT, don\u0026rsquo;t be surprised when parts of Discord stops working.\u003c/li\u003e\n\u003cli\u003eYou might also find that your ISP doesn\u0026rsquo;t support ipv6, you can of course solve this in the crazy person way and start your own ISP like network, or you could be more sensible, and use something like HE tunnels.\u003c/li\u003e\n\u003cli\u003eIOT devices generally don\u0026rsquo;t have great ipv6 support.\u003c/li\u003e\n\u003cli\u003eIf you are used to doing music streaming from your phone to maybe a Sonos speaker, that might break with option 108, given that Sonos doesn\u0026rsquo;t support ipv6, and your phone most likely won\u0026rsquo;t have an ipv4 address.\u003c/li\u003e\n\u003cli\u003eContainers and ipv6 - Generally not a good time, although it can be in some cases.\u003c/li\u003e\n\u003cli\u003eSome applications you host might listen to 0.0.0.0 instead of [::] (this supports both v4 and v6), if it\u0026rsquo;s an open source project, and you have the ability, please fix it in the project, and try to get it merged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"what-is-next\"\u003eWhat is next?\u003c/h2\u003e\n\u003cp\u003eMy plan is to start looking into diffrent NAT64 options given i have been out of that game for a bit. So look forward to a post comparing different options, and detailing what i will end up doing.\u003c/p\u003e\n","description":"The start of a series of posts related to building an ipv6 mostly home network and lab","image":"/images/content/intro-homelab-v6-hero.png","permalink":"http://localhost:1313/posts/ipv6-mostly-home-intro/","title":"A Glimpse into the Future: An introduction to IPv6 in your homelab"}]